<latex>
\ifdefined\wtexpart
\else
\documentclass{scrartcl}

\usepackage{libertine} 
\usepackage[libertine]{newtxmath}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{courier}

\usepackage[export]{adjustbox}
\usepackage{wrapfig}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsrefs}
\usepackage{calc}
\usepackage{funkey}
\usepackage{notation}
\usepackage{array}
\usepackage{menukeys}
\input{tikzstyles}
\usetikzlibrary{shapes.misc}
\usepackage{subfig}
\usepackage{longtable}
\usepackage{caption}
\usepackage{multirow}
\usepackage{tabulary}
\usepackage{hyperref}
\PassOptionsToPackage{hyphens}{url}
\usepackage[htt]{hyphenat}
\usepackage[scaled=.75]{beramono}
% Put a dot after section number.
\usepackage{secdot}
\usepackage[super]{nth}

% I want a proper degree symbol in text.
\usepackage{textcomp}       % additional symbols using companion encoding TS1
\usepackage{gensymb}        % provides macro \degree which works in text and math
\DeclareUnicodeCharacter{00B0}{\degree}

\newcommand\button[1]{\textit{#1}}
\newcommand\key[1]{\texttt{#1}}
\newcommand\screenshotA[1]{\centerline{\includegraphics[scale=0.5]{figures/#1}}}
\newcommand\screenshotB[1]{\centerline{\includegraphics[width=.8\textwidth]{figures/#1}}}
\newcommand\screenshotC[1]{\centerline{\includegraphics[width=.5\textwidth]{figures/#1}}}
\newcommand\screenshotLeft[1]{\begin{wrapfigure}{r}{7.5cm}{\centerline{\includegraphics[width=7.3cm]{figures/#1}}}\end{wrapfigure}}
\newcommand\screenshotLeftB[1]{\begin{wrapfigure}{r}{6cm}{\centerline{\includegraphics[width=5.8cm]{figures/#1}}}\end{wrapfigure}}
\newcommand\screenshotLeftC[1]{\begin{wrapfigure}{r}{4cm}{\centerline{\includegraphics[width=3.8cm]{figures/#1}}}\end{wrapfigure}}
\newcommand\screenshotTikz[1]{\centerline{\includetikz{figures/#1}}}
\newcommand\coloredlink[1]{\textcolor{blue!75!black}{\underline{\smash{#1}}}}
\newcommand\wikilink[2]{\href{http://imagej.net/#1}{\coloredlink{#2}}}
\newcommand\otherlink[2]{\href{#1}{\coloredlink{#2}}}
\newcommand\TODO[1]{\textcolor{red}{#1}}

% Small font in verbatime environment.
\makeatletter
\def\verbatim{\small\@verbatim \frenchspacing\@vobeyspaces \@xverbatim}
\makeatother

% Small images in text (for e.g. small icon).
\newcommand*{\smallimg}[1]{%
  \raisebox{-.1\baselineskip}{%
    \includegraphics[
      height=0.8\baselineskip,
      width=\baselineskip,
      keepaspectratio,
    ]{figures/#1}%
  }%
}

% Properly hyphen TrackMate & TrackScheme
\newcommand\TrackScheme[0]{Track\-Scheme\xspace}
\newcommand\TrackMate[0]{Track\-Mate\xspace}

% Less space when we make bullet lists.
\newenvironment{myitemize}
{ \begin{itemize}
    \setlength{\itemsep}{2pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{itemize}                  } 


% Syntax highlighting for code.
\usepackage{color}
\definecolor{sh_comment}{rgb}{0.12, 0.38, 0.18 }
\definecolor{sh_keyword}{rgb}{0.37, 0.08, 0.25}  
\definecolor{sh_string}{rgb}{0.06, 0.10, 0.98} 

\usepackage{listings}
\lstset{
	rulesepcolor=\color{black},
	showstringspaces=false,showtabs=false,tabsize=2,
	basicstyle=\ttfamily\small,
	stringstyle=\color{sh_string},
	keywordstyle = \color{sh_keyword}\bfseries,
	commentstyle=\color{sh_comment}\itshape,
	% escapebegin={\lstsmallmath}, escapeend={\lstsmallmathend}
	breaklines=true,
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

% Tables in the Wiki and LaTeX
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}
\newcommand\tablecell[2][&]{#2 #1}

% Highlight a sentence or word of wisdom like for amsbox
\newcommand\amsbox[1]{\begin{center}
	\begin{tikzpicture}[baseline=(char.base)]
		\node(char)[draw,
			fill=lightgray!20,
			shape=rectangle,
			drop shadow,
			rounded corners,
			minimum width=6cm,
			text width=13cm]
			{#1};
	\end{tikzpicture}
\end{center}
}













\title{\protect{\includegraphics[width=8cm]{figures/TrackMate_logo.png}}\\TrackMate documentation.\\Part 4: Extending TrackMate}
\author{Jean-Yves Tinevez}

\begin{document}
\maketitle
</latex>


<wiki>
__TOC__
</wiki>
<latex>
\newpage
\tableofcontents
\fi
</latex>



%----------------------------------------------------------------------------------------
%                                PART IV: EXTENDING TRACKMATE.
%----------------------------------------------------------------------------------------

\newpage
\part{Extending TrackMate.}
%--------------------------

Do you have a tracking or a detection algorithm you want to implement? Of course you can write a whole software from scratch. But at some point you will have to design a model to hold the data, to write code that can load and save the results, visualize them, have even a minimalistic GUI, and allow for the curation of the algorithm outcome. This can be long, tedious and boring, while the part that interests you is just the algorithm you are working on.

We propose using TrackMate as a home for your algorithm. The framework is already there; it might not be perfect but can get your algorithm integrated very quickly. And then you can benefit from other modules, which provide GUI elements, visualization, \etc.
The subject of extending TrackMate is not completely trivial. However, recent advances in the \otherlink{http://www.scijava.org/}{SciJava} package, brewed by the Fiji and ImageJ2 teams considerably simplified the task. It should be of no difficulty for an average Java developer.
The following tutorials show how to integrate a module of each kind in TrackMate. They are listed by increasing complexity, and it is a good idea to practice them in this order.



















%----------------------------------------------------------------------------------------
%                                EDGE ANALYZER
%----------------------------------------------------------------------------------------








\section{How to write your own edge feature analyzer algorithm for TrackMate.}
%----------------------------------------------------------------------------



\subsection{Introduction.}
%-------------------------

This page is a tutorial that shows how to integrate your own edge feature analyzer algorithm in TrackMate. It is the first in the series of tutorials dedicated to TrackMate extension, and should be read first by scientists willing to extend TrackMate. 

All these tutorials assume you are familiar with Java development. You should be at ease with java core concepts such as object oriented design, inheritance, interfaces, \etc.  Ideally you would even know that maven exists and that it can help you to compile software. Beyond this, the tutorials will provide what you need to know. 

Edge feature analyzers are algorithms that can associate one or more scalar numerical features  to an edge, or a link between two spots in TrackMate. For instance, the instantaneous velocity is an edge feature (you need two linked spots to compute a displacement and a time interval), which happens to be provided by the algorithm named \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/edges/EdgeVelocityAnalyzer.java}{EdgeVelocityAnalyzer.java}.




\subsection{TrackMate modules.}
%------------------------------

TrackMate is extended by writing \textit{modules}. Modules are just the basic algorithms that provide TrackMate with core functionality, that the GUI and API wrap. There are 7 classes of modules:

\begin{myitemize}
	\item detection algorithms
	\item particle-linking algorithms
	\item numerical features for spots (such as mean intensity, \etc.)
	\item numerical features for links (such as velocity, orientation, \etc.)
	\item numerical features for tracks (total displacement, length, \etc.)
	\item visualization tools
	\item post-processing actions (exporting, data massaging, \etc.)
\end{myitemize}

All of these modules implement an interface, specific to the module class. For instance, an edge analyzer algorithm will implement the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/edges/EdgeAnalyzer.java}{EdgeAnalyzer} interface. 
There are therefore seven interfaces. They do have in common that they all extend the mother module interface called \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/TrackMateModule.java}{TrackMateModule}.

TrackMateModule is used for two basic purpose:

\begin{myitemize}
	\item It itself extends the SciJavaPlugin interface, which will fuel the automatic discovery of new modules. We will discuss this point last.

	\item It has basic methods for the GUI integration:	
	\begin{myitemize}
		\item  \texttt{getKey()} returns a unique string identifier that is used internally to reference the algorithm. For instance: \texttt{"EDGE\_VELOCITY\_ANALYZER"}
		\item  \texttt{getName()} returns a string suitable to be displayed in the GUI that named the algorithm. For instance \texttt{"Edge velocity"}.
		\item  \texttt{getIcon()} returns an \texttt{ImageIcon} to be displayed in the GUI.
		\item  \texttt{getInfoText()} returns a html string that briefly documents what the algorithm does. Basic html markup is accepted, so you can have something like \\ \texttt{"<html>Plot the number of spots in each frame as a \\ function of time. Only the <u>filtered</u> spots are \\ taken into account.</html>"}
	\end{myitemize}

\end{myitemize}

These are the methods used to integrate you module within the GUI. According to the class of the module, some might be plainly ignored. For instance, the edge analyzers subject of this tutorial ignore the icon and info text, since they are used silently within the GUI to provide new features. 



\subsection{Basic project structure.}
%------------------------------------

Before we step into the edge analyzers specific, you want to setup a development environment that will ease TrackMate module development. Rather than listing the requirement, just checkout \otherlink{https://github.com/fiji/TrackMate-examples/}{this github repository}, and clone it. It contains the files of this tutorial series and more importantly, is configured to depend on the latest TrackMate version, which will make it available to your code. 

Compiling this project with maven will generate a jar, that you will be able to drop in the fiji plugins folder. Your modules will then be automatically detected and integrated in TrackMate.
But more on this later.

\subsection{Core class hierarchy.}
%------------------------------

Let's get back on our edge analyzer. 
For this tutorial, we are going to do something simple, at least mathematically. We will write an edge analyzer that can return the angle (in radians) of a link in the XY plane. Nothing more. 
So create a package for your new analyzer in our project, for instance \texttt{fiji.plugin.\\ trackmate.examples.edgeanalyzer}.
In this package, create a class \texttt{EdgeAngleAnalyzer} and let it implement the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/edges/EdgeAnalyzer.java}{EdgeAnalyzer} interface. You should be getting something like this:

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.edgeanalyzer;

import fiji.plugin.trackmate.features.edges.EdgeAnalyzer;

public class EdgeAngleAnalyzer implements EdgeAnalyzer
{
}
\end{lstlisting}

It is important to note that we provide a blank constructor. This is very important: with the way we use SciJavaPlugin integration, we cannot use the constructor to pass any object reference. If your analyzer needs some objects which are not provided through the interface methods, then you cannot code it with TrackMate directly. However we should cover most use-cases with what we have. 


\subsection{Feature analyzers specific methods.}
%-----------------------------------------------

Eclipse will immediately complain (if you are using Eclipse) that your class needs to implement some abstract method. A variety of methods popup.
We see the general module methods we discussed above, plus some specific to edge analyzers. Actually, most of the new methods are generic for \textit{all} the feature analyzers (spot, track or edge). These methods belong to the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/FeatureAnalyzer.java}{FeatureAnalyzer} interface, which \texttt{EdgeAnalyzer} extends, of course.

They exist because TrackMate needs to know what your feature analyzer does. Since it computes numerical features, it needs to know what features it computes, their name, their short name (when we want to show them in crowded part of the GUI) and their physical dimension. Indeed, TrackMate wants to know the dimension of the feature you generate, for it was coded in part by a conflicted physicist who does not want angles and velocities to be plotted on the same graph.

These 6 methods are:

\begin{myitemize}

	\item \texttt{getFeatures()} returns a list of string that identifies the features the analyzer generate. There can be more than one. This list must contain strings that can be used in a XML file. Historically, we use capitalized strings, in the shape of java constants, such as \texttt{DISPLACEMENT}. We call them feature keys.

	\item \texttt{getFeatureNames()} returns a map that links the feature keys to the feature names. For instance in the GUI, we want to display "Displacement" rather than "DISPLACEMENT", so that is what this map is about. It is important that the keys of this map are the keys defined in the list above. 

	\item \texttt{getFeatureShortNames()} returns another map with the same rules. We just use its value to display short names of features when this is needed in the GUI. There are no general advice on how to shorten your feature names; just try until it fits.

	\item \texttt{getFeatureDimensions()} returns a last map, that gives a dimension to your features. Physical dimensions are listed in the  \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/Dimension.java}{Dimension enum}.

	\item \texttt{getIsIntFeature()} is just about sugar coating. It returns a map that tells what features are integer mapped. For instance, if you have a feature that count things, such as number of neighbors, you should map this feature to \texttt{true} here. This one is actually not \textit{really}useful; there will be no problem, no loss of precision if you do not set it right. It's just about having numbers displayed correctly. We wanted that when there were 2 neighbors, the number of neighbors displayed was "2" and not "2.0000000000001". In our case, we measure an angle, so this feature should map to \texttt{false}.

	\item\texttt{isManualFeature()} returns a single flag that affects \textbf{all} the features calculated by this analyzer. Manual features are special features that were introduced in TrackMate v2.3.0. Let's leave that aside for now. Our angle feature is calculated automatically by the code we are just about to write. So this method should return \texttt{false}.

\end{myitemize}

In this tutorial, our analyzer just returns one feature, which is an angle. So a concrete implementation could be:

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.edgeanalyzer;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.swing.ImageIcon;

import fiji.plugin.trackmate.Dimension;
import fiji.plugin.trackmate.features.edges.EdgeAnalyzer;

public class EdgeAngleAnalyzer implements EdgeAnalyzer
{

	// The string key that identifies our analyzer.
	private static final String KEY = "Edge angle";
	// The only feature we compute here.
	private static final String EDGE_ANGLE = "EDGE_ANGLE";
	private static final List< String > FEATURES = new ArrayList< String >( 1 );
	private static final Map< String, Boolean > IS_INT = new HashMap< String, Boolean >( 1 );
	public static final Map< String, String > FEATURE_NAMES = new HashMap<String, String>(1);
	public static final Map< String, String > FEATURE_SHORT_NAMES = new HashMap< String, String >( 1 );
	public static final Map< String, Dimension > FEATURE_DIMENSIONS = new HashMap< String, Dimension >( 1 );

	// Let's set the feature list, names, short names and dimensions.
	static
	{
		FEATURES.add( EDGE_ANGLE );
		IS_INT.put( EDGE_ANGLE,  false );
		FEATURE_NAMES.put( EDGE_ANGLE, "Link angle" );
		FEATURE_SHORT_NAMES.put( EDGE_ANGLE, "Angle" );
		FEATURE_DIMENSIONS.put( EDGE_ANGLE, Dimension.ANGLE );
	}

	private long processingTime;

	/*
	 * TRACKMATEMODULE METHODS
	 */

	@Override
	public String getKey()
	{
		return KEY;
	}

	// Return a user-compliant name for this analyzer.
	@Override
	public String getName()
	{
		return "Edge angle";
	}

	// We do not use info texts for any feature actually.
	@Override
	public String getInfoText()
	{
		return "";
	}

	// The same: we don't use icons for features.
	@Override
	public ImageIcon getIcon()
	{
		return null;
	}

	@Override
	public List< String > getFeatures()
	{
		return FEATURES;
	}

	@Override
	public Map< String, String > getFeatureShortNames()
	{
		return FEATURE_SHORT_NAMES;
	}

	@Override
	public Map< String, String > getFeatureNames()
	{
		return FEATURE_NAMES;
	}

	@Override
	public Map< String, Dimension > getFeatureDimensions()
	{
		return FEATURE_DIMENSIONS;
	}

	@Override
	public Map<String, Boolean> getIsIntFeature()
	{
		return Collections.unmodifiableMap(IS_INT);
	}

	@Override
	public boolean isManualFeature() 
	{
		// This feature is calculated automatically.
		return false;
	}
\end{lstlisting}



\subsection{Multithreading \& Benchmarking methods.}
%-------------------------------------------------

There are also 4 methods which we will skip right now. They are related to the multi-threading aspect of the analyzer. You can code your analyzer to exploit a multithreaded environment, and TrackMate will configure it through the following methods:

\begin{lstlisting}[language=java]
	@Override
	public void setNumThreads()
	{
		// We ignore multithreading for this tutorial.
	}

	@Override
	public void setNumThreads( final int numThreads )
	{
		// We ignore multithreading for this tutorial.
	}

	@Override
	public int getNumThreads()
	{
		// We ignore multithreading for this tutorial.
		return 1;
	}
\end{lstlisting}

\noindent There is also 
\begin{lstlisting}[language=java]
public long getProcessingTime()
\end{lstlisting} 
that returns how much milliseconds was spent on computing the features. 



\subsection{The core methods.}
%-----------------------------

What is really important is the two methods that actually perform the work:

\begin{myitemize}
	\item isLocal()
	\item process( Collection< DefaultWeightedEdge > edges, Model model )
\end{myitemize}
Let's see how they would look for our example angle analyzer.



\subsubsection{isLocal().}
%----------------------------------

This method simply returns a boolean that states whether the features you compute are \textit{local} ones or not.  By local we mean the following: Does your feature value for an edge depends on the other edges? If no, then it is a local feature: it does not affect the other edges. If yes, then it is non local. Note that it applies to all the features provided by an analyzer.

This distinction fosters some optimization in TrackMate. TrackMate does automated and manual tracking. Allowing for both simultaneously in the same software proved difficult to balance, particularly when the goal is to offer good performance when manually correcting large datasets. When a manual modification of the data is made, TrackMate recomputes all the features, so that they are always in sync. But if a single punctual modification is made on an edge, you want to recompute features only for this edge, not for all the others if they are not affected. TrackMate can do that if the feature is local. This is why this method exists. 

An example of a local edge feature would be the instantaneous velocity. The velocity of an edge only depends on this edge and not on the rest. You might say that if you modify the position of a spot, all the edges touching this spot will be affected, so it is not local. But no: all the edges touching the spot will be modified, therefore will be marked for update, but the other edges that are not modified will not have their velocity affected. So the velocity is a local feature. 

An example of a non-local edge feature would be the distance of an edge to its closest neighbor. If you move an edge, its own feature value will be affected. But this will also affect the closest distance to many other edges. So it is non-local and we \textit{a priori} have to recompute it for all edges. 

In our case, we are coding an analyzer that returns the angle of a single edge, regardless of the angles of the other edges. It is therefore a local feature. 



\subsubsection{process( Collection< DefaultWeightedEdge > edges, Model model ).}
%-----------------------------------------------------------------------------------------------------

The method that actually performs the work is the less elaborated. The concrete implementation is provided with \texttt{edges}, the collection of the edge whose features are to be calculated, and \texttt{model}, the TrackMate model that holds all the information you need.
There is just one thing to know: Once you computed the numerical value of your feature, you need to store it in the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/FeatureModel.java}{FeatureModel}. The feature model is a part of the main model.
It works like a 2D Map:

\begin{lstlisting}[language=java]
	final FeatureModel fm = model.getFeatureModel();
	Double val = Double.valueOf(3.1451564);
	String FEATURE = "MY_AWESOME_EDGE_FEATURE";
	fm.putEdgeFeature( edge, FEATURE, val );
\end{lstlisting}

\noindent And for our XY edge angle, here are the methods content:

\begin{lstlisting}[language=java]
	@Override
	public void process( final Collection< DefaultWeightedEdge > edges, final Model model )
	{
		final FeatureModel fm = model.getFeatureModel();
		for ( final DefaultWeightedEdge edge : edges )
		{
			Spot source = model.getTrackModel().getEdgeSource( edge );
			Spot target = model.getTrackModel().getEdgeTarget( edge );

			final double x1 = source.getDoublePosition( 0 );
			final double y1 = source.getDoublePosition( 1 );
			final double x2 = target.getDoublePosition( 0 );
			final double y2 = target.getDoublePosition( 1 );

			final double angle = Math.atan2( y2 - y1, x2 - x1 );
			fm.putEdgeFeature( edge, EDGE_ANGLE, Double.valueOf( angle ) );
		}
	}

	@Override
	public boolean isLocal()
	{
		return true;
	}
\end{lstlisting}



\subsection{Making the analyzer discoverable.}
%---------------------------------------------

Right now, your analyzer is functional. It compiles and would return expected results. Everything is fine.

Except that TrackMate doesn't even know it exists. It sits in his lonely corner and is perfectly useless. 

Until TrackMate v2.2.0, there was no other to extend TrackMate than to modify it or fork it, then recompile and redeploy it from scratch. With v2.2.0 we benefited from the effort of the ImageJ2 team who built a very simple and very clever discovery mechanism, that allow to simply drop a jar in the plugins folder of Fiji and have TrackMate be aware of it. On top of it all, it is plain and simple.

Just add the following line before the class declaration:
\begin{lstlisting}[language=java]
@Plugin( type = EdgeAnalyzer.class )
public class EdgeAngleAnalyzer implements EdgeAnalyzer
{
...
\end{lstlisting}

and that's it. 

\amsbox{To make a TrackMate module discoverable in TrackMate, just annotate its class with 
			\texttt{@Plugin( type = TrackMateModuleClassExtending.class )}.}
			
Just the line \texttt{@Plugin( type = EdgeAnalyzer.class )} is enough. There are also mechanisms that allow fine tuning of priority, visibility (in the GUI menus), or enabling/disabling, but we will see this later.  
Right now, just compile your project, and drop the resulting jar in the Fiji plugins folder. Here is what you get:

\screenshotB{TrackMate_DevelopEdgeAnalyzer.png}

Great, no?
You can find the full source for this example \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/edgeanalyzer/EdgeAngleAnalyzer.java}{here}. It can also be used as a template for your analyzer.


<wiki>
[[Category:Tutorials]]
</wiki>


















%----------------------------------------------------------------------------------------
%                                TRACK ANALYZER
%----------------------------------------------------------------------------------------



















\section{How to write your own track feature analyzer algorithm for TrackMate.}
%-------------------------------------------------------------------------------



\subsection{Introduction.} 
%-------------------------

This article is the second in the series dedicated to extending TrackMate with your own modules. Here we focus on creating \textbf{feature analyzers}: small algorithms that calculate one or several numerical values for the TrackMate results. The previous section focused on writing edge analyzers: algorithms that allocate a numerical value to the link between two spots.
In this section, we will create a \textbf{feature analyzer for tracks} that calculate numerical values for whole tracks. To make it simple, and also to answer the request of a colleague, we will make an analyzer that reports the location of the starting and ending points of a track. 
Actually, we will not learn much beyond what we saw previously. The only little change is that our analyzer will generate six numerical values instead of one. 
We will use the \wikilink{SciJava}{SciJava} discovery mechanism as before, but just for the sake of it, we will introduce how to \textbf{disable} modules.



\subsection{Track analyzers.}
%-----------------------------

All the track feature analyzers must implement \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/track/TrackAnalyzer.java}{TrackAnalyzer interface}. Like for the \\ \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/edges/EdgeAnalyzer.java}{EdgeAnalyzer} interface, it extends both

\begin{myitemize}
	\item \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/FeatureAnalyzer.java}{FeatureAnalyzer} that helps you declaring what you compute, 
	
	\item and \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/TrackMateModule.java}{TrackMateModule}, that is in charge of the integration in TrackMate.

\end{myitemize}
The only changes for us are two methods specific to tracks:

\begin{lstlisting}[language=java]
public void process( Collection< Integer > trackIDs, Model model );
\end{lstlisting}
the does the actual feature calculation for the specified tracks, and

\begin{lstlisting}[language=java]
public boolean isLocal();
\end{lstlisting} 
that specified whether the calculation of the features for one track affects only this track or all the tracks. For the discussion on local \textit{vs} non-local feature analyzers, report to the previous section.


\subsection{Track feature analyzer header.}
%------------------------------------------

Like all TrackMate modules, you need to annotate your class to make it discoverable by TrackMate. It takes the following shape:

\begin{lstlisting}[language=java]
@Plugin( type = TrackAnalyzer.class )
public class TrackStartSpotAnalyzer implements TrackAnalyzer
{
        // etc...
\end{lstlisting}
and that's good enough.




\subsection{Declaring features.}
%-------------------------------

Declaring the features your provide is done as before. This time, a single analyzer returns 6 values, so you need to declare them. Here is the related code:

\begin{lstlisting}[language=java]
@Plugin( type = TrackAnalyzer.class )
public class TrackStartSpotAnalyzer implements TrackAnalyzer
{

	private static final String KEY = "TRACK_START_SPOT_ANALYZER";
	public static final String TRACK_START_X = "TRACK_START_X";
	public static final String TRACK_START_Y = "TRACK_START_Y";
	public static final String TRACK_START_Z = "TRACK_START_Z";
	public static final String TRACK_STOP_X = "TRACK_STOP_X";
	public static final String TRACK_STOP_Y = "TRACK_STOP_Y";
	public static final String TRACK_STOP_Z = "TRACK_STOP_Z";
	private static final List< String > FEATURES = new ArrayList< String >( 6 );
	private static final Map< String, String > FEATURE_SHORT_NAMES = new HashMap< String, String >( 6 );
	private static final Map< String, String > FEATURE_NAMES = new HashMap<String, String>(6);
	private static final Map< String, Dimension > FEATURE_DIMENSIONS = new HashMap< String, Dimension >( 6 );

	static
	{
		FEATURES.add( TRACK_START_X );
		FEATURES.add( TRACK_START_Y );
		FEATURES.add( TRACK_START_Z );
		FEATURES.add( TRACK_STOP_X );
		FEATURES.add( TRACK_STOP_Y );
		FEATURES.add( TRACK_STOP_Z );

		FEATURE_NAMES.put( TRACK_START_X, "Track start X" );
		FEATURE_NAMES.put( TRACK_START_Y, "Track start Y" );
		FEATURE_NAMES.put( TRACK_START_Z, "Track start Z" );
		FEATURE_NAMES.put( TRACK_STOP_X, "Track stop X" );
		FEATURE_NAMES.put( TRACK_STOP_Y, "Track stop Y" );
		FEATURE_NAMES.put( TRACK_STOP_Z, "Track stop Z" );

		FEATURE_SHORT_NAMES.put( TRACK_START_X, "X start" );
		FEATURE_SHORT_NAMES.put( TRACK_START_Y, "Y start" );
		FEATURE_SHORT_NAMES.put( TRACK_START_Z, "Z start" );
		FEATURE_SHORT_NAMES.put( TRACK_STOP_X, "X stop" );
		FEATURE_SHORT_NAMES.put( TRACK_STOP_Y, "Y stop" );
		FEATURE_SHORT_NAMES.put( TRACK_STOP_Z, "Z stop" );

		FEATURE_DIMENSIONS.put( TRACK_START_X, Dimension.POSITION );
		FEATURE_DIMENSIONS.put( TRACK_START_Y, Dimension.POSITION );
		FEATURE_DIMENSIONS.put( TRACK_START_Z, Dimension.POSITION );
		FEATURE_DIMENSIONS.put( TRACK_STOP_X, Dimension.POSITION );
		FEATURE_DIMENSIONS.put( TRACK_STOP_Y, Dimension.POSITION );
		FEATURE_DIMENSIONS.put( TRACK_STOP_Z, Dimension.POSITION );
	}
        
	/*
	 * FEATUREANALYZER METHODS
	 */

	@Override
	public List< String > getFeatures()
	{
		return FEATURES;
	}

	@Override
	public Map< String, String > getFeatureShortNames()
	{
		return FEATURE_SHORT_NAMES;
	}

	@Override
	public Map< String, String > getFeatureNames()
	{
		return FEATURE_NAMES;
	}

	@Override
	public Map< String, Dimension > getFeatureDimensions()
	{
		return FEATURE_DIMENSIONS;
	}
\end{lstlisting}
Let's compute them now.




\subsection{Accessing tracks in TrackMate.} 
%-------------------------------------------

In the previous article, we went maybe a bit quickly on how to access data in TrackMate. This is not the goal of this series, but here is a quick recap:

All the track structure is stored in a sub-component of the model called the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/TrackModel.java}{TrackModel}. It stores the collection of links between two spots that builds a graph, and has some rather complex logic to maintain a list of connected components: the tracks. 

The tracks themselves are indexed by their ID, stored as an <code>int</code>, that has no particular meaning. Once you have the ID of track, you can get the spots it contains with

\begin{lstlisting}[language=java]
trackModel.trackSpots( trackID )
\end{lstlisting}

\noindent and its links (or edges) with 

\begin{lstlisting}[language=java]
trackModel.trackEdges( trackID )
\end{lstlisting}

\noindent  Let's exploit this.



\subsection{Calculating the position of start and end points.}
%-------------------------------------------------------------

Well, it is just about retrieving a track and identifying its starting and end points. Here is the whole code for the processing method:

\begin{lstlisting}[language=java]

	@Override
	public void process( final Collection< Integer > trackIDs, final Model model )
	{
		// The feature model where we store the feature values:
		final FeatureModel fm = model.getFeatureModel();

		// Loop over all the tracks we have to process.
		for ( final Integer trackID : trackIDs )
		{
			// The tracks are indexed by their ID. Here is how to get their
			// content:
			final Set< Spot > spots = model.getTrackModel().trackSpots( trackID );
			// Or .trackEdges( trackID ) if you want the edges.

			// This set is NOT ordered. If we want the first one and last
			// one we have to sort them:
			final Comparator< Spot > comparator = Spot.frameComparator;
			final List< Spot > sorted = new ArrayList< Spot >( spots );
			Collections.sort( sorted, comparator );

			// Extract and store feature values.
			final Spot first = sorted.get( 0 );
			fm.putTrackFeature(trackID,TRACK_START_X, Double.valueOf(first.getDoublePosition(0)));
			fm.putTrackFeature(trackID,TRACK_START_Y, Double.valueOf(first.getDoublePosition(1)));
			fm.putTrackFeature(trackID,TRACK_START_Z, Double.valueOf(first.getDoublePosition(2)));

			final Spot last = sorted.get( sorted.size() - 1 );
			fm.putTrackFeature(trackID, TRACK_STOP_X, Double.valueOf(last.getDoublePosition(0)));
			fm.putTrackFeature(trackID, TRACK_STOP_Y, Double.valueOf(last.getDoublePosition(1)));
			fm.putTrackFeature(trackID, TRACK_STOP_Z, Double.valueOf(last.getDoublePosition(2)));
		}
	}
\end{lstlisting}

The whole code for the analyzer can be found \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/trackanalyzer/TrackStartSpotAnalyzer.java}{here}.



\subsection{Wrapping up.}
%------------------------

The new track features get properly integrated along with other native features:

\screenshotB{TrackMate_TrackAnalyzerExample.png}

In the next article we will build a spot analyzer and complicate things a bit, by introducing the notion of \textit{priority}. But before this, a short word on how to disable a module.




\subsection{How to disable a module.}
%-------------------------------------

Suppose you have in your code tree a TrackMate module you wish not to use anymore. The trivial way would be to delete its class, but here is another one what allows us to introduce \wikilink{SciJava}{SciJava} plugin annotation parameters. 

The \texttt{@Plugin( type = TrackAnalyzer.class )} annotation accepts extra parameters on top of the \texttt{type} one. They all take the shape of a \texttt{key = value} pair, and a few of them allow the fine tuning of the TrackMate module integration.

The first one we will see is the \texttt{enabled} value. It accepts a \texttt{boolean} as value and by default it is \texttt{true}. Its usage is obvious:

\amsbox{If you want to disable a TrackMate module, add the \texttt{enabled = false} annotation parameter.}

\noindent Like this:

\begin{lstlisting}[language=java]
@Plugin( type = TrackAnalyzer.class, enabled = false )
\end{lstlisting}

Disabled modules are not even instantiated. They are as good as dead, except that you can change your mind easily. By the way, you can see that the TrackMate source tree has many of these disabled modules...



























%----------------------------------------------------------------------------------------
%                                SPOT ANALYZER
%----------------------------------------------------------------------------------------



















\section{How to write your own track feature analyzer algorithm for TrackMate.}
%-------------------------------------------------------------------------------




\subsection{Introduction.} 
%-------------------------

This third article in the series dedicated to extending \wikilink{TrackMate}{TrackMate} deals with spot feature analyzer. This is the last of the three kind of feature analyzers you can create, and it focuses on spots, or detections. 

Spot features are typically calculated from the spot location and the image data. For instance, there is a spot feature that reports the mean intensity within the spot radius. You need to have the spot location, its radius and the image data to compute it.

In this tutorial, we will generate an analyzer that is not directly calculated from the image data. This will enable us to skip over introducing \wikilink{ImgLib2}{ImgLib2} API, which would have considerably augmented the length of this series. But this choice does not only aim at nurturing my laziness: We will make our feature \textbf{depend on other features} which will allow us to introduce \textbf{analyzers priority}. 

But before this, let's visit the spot feature analyzers specificities. 




\subsection{Spot analyzers and spot analyzer factories.}
%-------------------------------------------------------

In the two previous articles we dealt with \wikilink{How to write your own edge feature analyzer algorithm for TrackMate}{edge} and \wikilink{How to write your own track feature analyzer algorithm for TrackMate}{track} analyzers. We could make them in a single class, and this class embedded both the code for

\begin{myitemize}
	\item TrackMate integration (feature names, dimensions, declaration, etc...);
	\item and actual feature calculation.
\end{myitemize}
For spot analyzer, the two are separated. 

You must first create a \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/spot/SpotAnalyzerFactory.java}{SpotAnalyzerFactory}. This factory will be in charge of the TrackMate integration. The interface extends both the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/TrackMateModule.java}{TrackMateModule} and the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/FeatureAnalyzer.java}{FeatureAnalyzer} interfaces. It is the class you will need to annotate with a \wikilink{SciJava}{SciJava} annotation for automatic discovery.

But it is also in charge of instantiating \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/spot/SpotAnalyzer.java}{SpotAnalyzer}s. As you can see, this interface just extends ImgLib2  \otherlink{https://github.com/imglib/imglib/blob/master/algorithms/core/src/main/java/net/imglib2/algorithm/Algorithm.java}{Algorithm}, so all parameters will have to be passed in the constructor, which can be what you want thanks to the factory. We do not need a return value method, because results are stored directly inside the spot objects. But we will see this later.

Let's get started with our example.



\subsection{The spot analyzer factory.}
%--------------------------------------

We want to generate an analyzer that will compute for each spot, its intensity relative to the mean intensity of all spots in the same frame. So you get for this feature a value of 1 if its intensity is equal to the mean, etc... We could have our analyzer actually compute the pixel intensity for each spot, take the mean over a frame, then normalize, etc... But, there is an analyzer that already computes the spot intensity and we can re-use it. Check the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/spot/SpotIntensityAnalyzerFactory.java}{SpotIntensityAnalyzerFactory}.

It is a good idea to reuse this value in our computations, both for the quickness of development and runtime performance. But if we do so, we must ensure that the feature we depend on is available when our new analyzer runs. There is a way to do that, thanks to the notion of \textbf{priority}, which we will deal with later. 

Right now, let's focus on the factory class itself. There is not much to say: its content resembles all the feature analyzers we saw so far. So I am going to skip over the details and point you to the full source code \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/spotanalyzer/RelativeIntensitySpotAnalyzerFactory.java}{here}.

The one interesting part is the factory method in charge of instantiating the \texttt{SpotAnalyzer}:

\begin{lstlisting}[language=java]
@Override
	public SpotAnalyzer< T > getAnalyzer( Model model, ImgPlus< T > img, int frame, int channel )
	{
		return new RelativeIntensitySpotAnalyzer< T >( model, frame );
	}
\end{lstlisting}
Since we want to build a feature that does not need the image data, the constructor just skips the image reference. And that's it. We must now move on to the analyzer itself to implement the feature calculation logic.



\subsection{The spot analyzer.}
%------------------------------

As you noted in the above method, each analyzer is meant to operate only on one frame. It can access the whole model, but it is supposed to compute the values for all the spots of a single frame. This permits multithreading: The factory will be asked to generate as many analyzer as there is threads available, and they will run concurrently. And we, as we build our analyzer - do not have to worry about concurrent issues. 

A little word about the expected execution context: The TrackMate GUI operates in steps, as you have noted. First the detection step generates spots, then they are filtered, then they are tracked, etc... Therefore, when I said earlier that the whole model is available for calculation, this is not entirely true. When using the GUI, spot numerical features are used to filter spots after they have been detected.  So that this stage, there is no tracks yet. There is not even filtered spots. A spot feature cannot depend on these objects, and this is a built-in limitation of TrackMate. So be cautious on what your numerical feature depends. 

Before we go into the code, here is quick recap on the TrackMate model API. After the detection step, the spots are stored in a \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/SpotCollection.java}{SpotCollection} object. It gathers all the spots, and can deal with their filtering visibility, etc... Spot analyzers are meant to operate only on one frame, so we will need to require the spot of this frame. The target frame is specified at construction time, by the factory. 

The \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/spot/SpotAnalyzer.java}{SpotAnalyzer} interface is pretty naked. There is nothing specific, and all the logic has to go in the \texttt{process()} method. There is no need to have a method to return the results of the computation, for spot objects can store their own feature values, thanks to the \texttt{Spot.putFeature(feature, value)} method.

Here is what the \texttt{process()} method of the analyzer looks like:

\begin{lstlisting}[language=java]
	@Override
	public boolean process()
	{
		/*
		 * Collect all the spots from the target frame. In a
		 * SpotAnalyzer, you cannot interrogate only visible
		 * spots, because spot features are typically used to
		 * determine whether spots are going to be visible or
		 * not. This happens in the GUI at the spot filtering
		 * stage: We are actually building a feature on which
		 * a filter can be applied. So the spot features must
		 * be calculated over ALL the spots.
		 */

		/*
		 * The spots are stored in a SpotCollection before they
		 * are tracked. The SpotCollection is the product of
		 * the detection step.
		 */
		final SpotCollection sc = model.getSpots();
		// 'false' means 'not only the visible spots, but all spots'.
		Iterator< Spot > spotIt = sc.iterator( frame, false );

		/*
		 * Compute the mean intensity for all these spots.
		 */

		double sum = 0;
		int n = 0;
		while ( spotIt.hasNext() )
		{
			final Spot spot = spotIt.next();
			// Collect the mean intensity in the spot radius.
			final double val = spot.getFeature( SpotIntensityAnalyzerFactory.MEAN_INTENSITY );
			sum += val;
			n++;
		}

		if ( n == 0 )
		{
			// Nothing to do here.
			return true;
		}

		final double mean = sum / n;

		/*
		 * Make a second pass to set the relative intensity of these
		 * spots with respect to the mean we just calculated.
		 */

		spotIt = sc.iterator( frame, false );
		while ( spotIt.hasNext() )
		{
			final Spot spot = spotIt.next();
			final double val = spot.getFeature( SpotIntensityAnalyzerFactory.MEAN_INTENSITY );
			final double relMean = val / mean;
			// Store the new feature in the spot
			spot.putFeature( RELATIVE_INTENSITY, Double.valueOf( relMean ) );
		}

		return true;
	}
\end{lstlisting}

The code for the whole class is \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/spotanalyzer/RelativeIntensitySpotAnalyzer.java}{here}.




\subsection{Using SciJava priority to determine order of execution.}
%-------------------------------------------------------------------

Now it's time to discuss the delicate subject of dependency. 

As stated above, our new analyzer depends on some other features to compute. Therefore, the analyzers that calculate these other features need to run \textit{before} our analyzer. Or else you will bet \texttt{NullPointerException}s randomly. 

TrackMate does not offer a real in-depth module dependency management. It simply offers to \textbf{determine} the order of analyzer execution thanks to the \wikilink{SciJava}{SciJava} plugin \textbf{priority parameter}. 

For instance, if you check the annotation part of the spot analyzer factory, you can see that there is an extra parameter, \texttt{priority}:

\begin{lstlisting}[language=java]
@Plugin( type = SpotAnalyzerFactory.class, priority = 1d )
\end{lstlisting}

This priority parameter accepts a \texttt{double} as value and this value determines the order of execution. Careful, the rule is the opposite of what would make sense for a priority: 

\amsbox{Feature analyzers are executed in order according to \textbf{increasing priority}. This means that analyzers with the greatest priority are executed last.}

By convention, if your feature analyzer depends on the features calculated by N other analyzers, you take the larger priority of these analyzers, and add 1. In our case, we depend on the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/features/spot/SpotIntensityAnalyzerFactory.java}{SpotIntensityAnalyzerFactory}, which as a priority of 0 (the default if the parameter is unspecified). So quite logically, we set the priority of our analyzer to be 1. This ensures the proper execution order.



\subsection{Wrapping up.}
%------------------------

Apart from the discussion on the priority and execution order, there is not much to say.  It works!

\screenshotB{TrackMate_CustomSpotAnalyzer_01.png}























%----------------------------------------------------------------------------------------
%                                CUSTOM VIEWER
%----------------------------------------------------------------------------------------











\section{How to write your own viewer for TrackMate.}
%-----------------------------------------------------



\subsection{Introduction.}
%--------------------------

Developing a custom view for \wikilink{TrackMate}{TrackMate} is \textit{hard} and painful. Of course it must be a graphical representation of the model: the tracking results with all intermediate steps. If you want to build something really useful, it has to be interactive and should allow modifying the model. And be aware that modifications might happen somewhere else. Performance is also critical: since it stands at the user interface, it must be responsive, and possibly deal with large models (millions of detections). 
One of the main good reason to extend TrackMate is most likely that there is ready some views available.

Still, it is perfectly possible to build something useful without fulfilling all these requirements. And we still hope that someday someone will contribute a view that displays the model in the orthogonal slicer of Fiji.

This tutorial introduces the \underline{view interfaces} of TrackMate, and since they deal with user interactions, we will also review the \underline{TrackMate event system}. As for the \wikilink{SciJava}{SciJava} discovery system, we will see how to make a TrackMate module available in TrackMate, but not visible to the user, using the \texttt{visible} parameter.



\subsection{A custom TrackMate view.}
%--------------------------------------

Like for the \wikilink{How_to_write_your_own_spot_feature_analyzer_algorithm_for_TrackMate}{spot feature analyzers}, a TrackMate view is separated in two parts, that each extends a different interface:

\begin{myitemize}

	\item  The  \otherlink{http://imagej.net/How_to_write_your_own_spot_feature_analyzer_algorithm_for_TrackMate}{TrackMateModelView}, that is the actual view of the model. All the hard work is done here.

	\item The \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/visualization/ViewFactory.java}{ViewFactory} that is a factory in charge of instantiating the view and of the integration in TrackMate. This interface extends the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/TrackMateModule.java}{TrackMateModule} interface, so we expect to find there some of the methods we discussed earlier, and the \wikilink{SciJava}{SciJava} annotation. 

\end{myitemize}
In this tutorial, we will build something simple. We will limit ourselves to develop a view that simple messages the user every time something happens in TrackMate. For instance, when the spots are detected, how many there are; if he selects spots and edges, how many of them; \etc. And we will just reuse the Fiji log window for this, which will save us from the full development of a graphical view of the model. 

But because this is a bit limited, we will not let the user pick this view as the main one, just after the detection step. A \wikilink{SciJava}{SciJava} parameter will be used to make it invisible in the view selection menu. To make good use of it, we still need some way to launch this view, but this will be the subject of the next tutorial. 
Right now, we just focus on building the view. 



\subsection{The ViewFactory.}
%----------------------------

The factory itself has nothing particular. On top of the TrackMateModule methods, it just has a method to instantiate the view it controls:

\begin{lstlisting}[language=java]
@Override
public TrackMateModelView create( Model model, Settings settings, SelectionModel selectionModel )
\end{lstlisting}

You can see that we can possibly pass 3 parameters to the constructor of the view itself: the model of course, but also the settings object, so that we can find there a link to the image object. The \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/visualization/hyperstack/HyperStackDisplayerFactory.java}{HyperStackDisplayer} uses it to retrieve the ImagePlus over which to display the TrackMate data.
The selection model is also offered, and the instance passed is the common one used in the GUI, so that a selection made by the user can be shared amongst all views. 




\subsection{The TrackMateModelView interface.}
%---------------------------------------------



\subsubsection{Methods.}
%-----------------------

This is where the hard work takes place and there is a lot to say. However, the method you find in this interface are scarce and relate just to general use, and most of them are not mandatory: 

\begin{myitemize}

	\item \begin{lstlisting}[language = java]
	public void render();
	\end{lstlisting} 
	This is the initialization method for your view. Your view should not show up to the user when it is instantiating, but only when this method is called. This allows TrackMate to properly manage the rendering. 

	\item \begin{lstlisting}[language = java]
	public void refresh();
	\end{lstlisting} 	
	This method should be in charge of updating the view whenever it is sensible to do so. Careful: it is \textbf{not} called automatically when the model has changed. You have to listen to model change yourself, and call this method manually if you want your view to be in sync. However, it \textbf{is} called automatically whenever the user changes a display setting (because views are not made to listen to GUI changes). But more on that below. 

	\item \begin{lstlisting}[language = java]
	public void clear();
	\end{lstlisting} 
	This one is rather explicit. It ensures a way to clear a view in case it is not kept in sync with the model changes.

	\item \begin{lstlisting}[language = java]
	public void centerViewOn( Spot spot );
	\end{lstlisting} 
	This is a non-mandatory convenience tool that allow centering a view (whatever it means) on a specific Spot. It is called for instance when the user selects \textbf{one} spot in the GUI: all the views that implement this method move and pan to show this spot.

	\item The three methods related to display settings: 
	\begin{lstlisting}[language = java]
	public Map< String, Object > getDisplaySettings();
	public void setDisplaySettings( String key, Object value );
	public Object getDisplaySettings( String key );
	\end{lstlisting}
	are explained below.

%	\item The three methods related to display settings: \underline{\texttt{public Map< String, Object > getDisplaySettings();}}, \underline{\texttt{public void setDisplaySettings( String key, Object value );}}  and  \underline{\texttt{public Object getDisplaySettings( String key );}} are explained below.

	\item \begin{lstlisting}[language = java]
	public Model getModel();
	\end{lstlisting}
	exposes the model this view renders. 

	\item \begin{lstlisting}[language = java]
	public String getKey();
	\end{lstlisting}
	Returns the unique key that identifies this view. Careful: this key <b>must</b> be the same that for the ViewFactory that can instantiates this view. This is used to save and restore the views present in a TrackMate session.

\end{myitemize}




\subsubsection{Display settings.}
%--------------------------------

It should be possible to configure the look and feel of your view, or even to set what is visible or not. This is made through display settings, and 3 methods are used to pass then around: 
\begin{lstlisting}[language = java]
	public Map< String, Object > getDisplaySettings();
	public void setDisplaySettings( final String key, final Object value );
	public Object getDisplaySettings( final String key );
\end{lstlisting}
Display settings are passed using a pair of key (as String) / value (as Object, that should be cast upon the right class). 

The TrackMate GUI allows the user to edit a limited series of display settings that ought to be common to all views. These are the settings you can tune on the antepenultimate panel of the GUI (spot visible or not, color by feature, etc...). If you feel like it, your view can just ignore them. Otherwise, their keys and desired classes are defined in the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/visualization/TrackMateModelView.java}{TrackMateModelView} interface. Check the static fields there.

Everytime the user changes a setting in the GUI, the new setting value is passed with the \texttt{setDisplaySettings()} method, then the \texttt{refresh()} method is called as well. 




\subsubsection{Listening to model changes.}
%------------------------------------------

You don't \textit{have to} keep your view in sync with the model. You can make something useful that would just capture a snapshot of the model as it is when you launch the view and be happy about it. But, TrackMate is about allowing both automatic and manual annotation of the image data, so most likely a very useful view will echoes the changes made to the model. Ideally it would even \textit{enable} these changes to be made. But this is out of the scope of this tutorial.

If you want to listen to changes made to the model, you have to register as a listener to it. This is made through
\begin{lstlisting}[language=java]
Model.addModelChangeListener( YourViewInstance );
\end{lstlisting}

and then you get a new method:
\begin{lstlisting}[language=java]
public void modelChanged( final ModelChangeEvent event )
\end{lstlisting}

The event itself can report 5 types of changes: 

\begin{myitemize}

	\item The spots detection is done. In the GUI, this is sent just after the detection step, before the initial filtering step.
	
	\item The spots are filtered reversibly. This is sent everytime you change anything on the spot filtering panel (a new filter, a threshold value, etc..).
	
	\item The tracking step is done. That just follows the tracking step in the GUI. 
	
	\item The tracks are filtered. Like for the spots.
	
	\item The model is \textit{modified}. By modification, we mean an incremental, manual modification of the model. The user might have deleted a spot, or moved it in space, or changed its size, or add an edge between two spots, \etc. In that case, the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/ModelChangeEvent.java}{ModelChangeEvent} instance can be interrogated to know what was changed, deleted, added, \etc.

\end{myitemize}




\subsubsection{Listening to selection changes.}
%-----------------------------------------------

The TrackMate GUI shares a common instance of  \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/SelectionModel.java}{SelectionModel} that stores the selection the user made. This is convenient when exploring the tracking results. 
Your view can be kept in sync with the selection changes by implementing the  \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/SelectionChangeListener.java}{SelectionChangeListener} interface. It adds a single method:
\begin{lstlisting}[language=java]
public void selectionChanged(SelectionChangeEvent event);
\end{lstlisting}



\subsection{A simple event logger.}
%----------------------------------

Let's keep our custom view simple: we will just build an event logger that recycles the IJ logger window to echo what happens to the model. We then of course have to implement the two listener interfaces mentioned above. But the code stays pretty simple: check \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/view/EventLoggerView.java}{here} for the details.

As for the factory, nothing fancy:

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.view;

import ij.ImageJ;
import ij.ImagePlus;

import javax.swing.ImageIcon;

import org.scijava.plugin.Plugin;

import fiji.plugin.trackmate.Model;
import fiji.plugin.trackmate.SelectionModel;
import fiji.plugin.trackmate.Settings;
import fiji.plugin.trackmate.TrackMatePlugIn_;
import fiji.plugin.trackmate.visualization.TrackMateModelView;
import fiji.plugin.trackmate.visualization.ViewFactory;

@Plugin( type = ViewFactory.class )
public class EventLoggerViewFactory implements ViewFactory
{

	private static final String INFO_TEXT = "<html>This factory instantiates an event logger view for TrackMate, that uses the IJ log window to just echo all the event sent by the model.</html>";

	public static final String KEY = "EVENT_LOGGER_VIEW";

	@Override
	public String getInfoText()
	{
		return INFO_TEXT;
	}

	@Override
	public ImageIcon getIcon()
	{
		return null;
	}

	@Override
	public String getKey()
	{
		return KEY;
	}

	@Override
	public String getName()
	{
		return "Event logger view";
	}

	@Override
	public TrackMateModelView create( final Model model, final Settings settings, final SelectionModel selectionModel )
	{
		return new EventLoggerView( model, selectionModel );
	}

	/*
	 * MAIN METHOD
	 */

	public static void main( final String[] args )
	{
		ImageJ.main( args );
		new ImagePlus( "../fiji/samples/FakeTracks.tif" ).show();
		new TrackMatePlugIn_().run( "" );
	}

}
\end{lstlisting}


Just note that the \wikilink{SciJava}{SciJava} annotation mention the \texttt{ViewFactory} class. This is enough to have the view selectable in the GUI menu:

\screenshotA{TrackMate_CustomView_2.png}

Note that this time, TrackMate good use of the \texttt{getName()} and \texttt{getInfoText()} methods. And here is what you get after a few manipulations:

\screenshotB{TrackMate_CustomView_1.png}




\subsection{Controlling the visibility of your view with the SciJava \texttt{visible} parameter.}
%----------------------------------------------------------------------------------------------------

Our view is a good dummy example. It is not that useful, and the info panel of the GUI could be used instead advantageously. We have nothing against it, but maybe we should not let users select it as the main view in the GUI, otherwise they might get frustrated (well, the HyperStack view is \textit{always} used, whatever you choose, so we could not mind, but eh). 

There is way to do that, just by tuning the SciJava annotation:

\amsbox{To make a TrackMate module available in TrackMate, but not visible in the GUI menus, use the annotation parameter \texttt{visible = false}.}

So editing the header of our ViewFactory to make it look like:

\begin{lstlisting}[language=java]
@Plugin( type = ViewFactory.class, visible = false )
public class EventLoggerViewFactory implements ViewFactory
\end{lstlisting}

is enough to hide it in the menu. This is different from the \texttt{enabled} parameter we saw in the previous section. The factory is instantiated and available in TrackMate; it just does not show up in the menu.
But how could we make use of it then? you want to ask. Fortunately, this is just the subject of the next section, on TrackMate actions. 


































%----------------------------------------------------------------------------------------
%                                CUSTOM ACTIONS.
%----------------------------------------------------------------------------------------












\section{How to write custom actions for TrackMate.}
%---------------------------------------------------



\subsection{Introduction.}
%-------------------------

Actions are a simple solution to the problem of adding random features to \wikilink{TrackMate}{TrackMate} without having to change the GUI too much. Adding buttons or dialogs or extra panels is cumbersome and it would complexify the GUI, which was meant to remain simple. A TrackMate action is a lazy workaround for this problem. You must keep in mind that is a placeholder for random feature ideas, and provided a quick and dirty way to test them.

A TrackMate action takes the shape of an item in a drop-down list in the last panel of the GUI. It can do more or less anything, since we pass everything to the action, even a reference to the GUI itself. Thanks to the \wikilink{SciJava}{SciJava} discovery mechanism, we do not have to worry about adding it on the GUI: it will automatically be listed in the action list. The drawback of this simplicity is that you cannot use it to provide elaborated user interaction mechanisms, such as the ones you can find in a view. 

In this tutorial, we will use it to launch the event logger we created in the previsou section of this series. If you remember, we saw in the last paragraph how to use the \texttt{visible = false} parameter the \wikilink{SciJava}{SciJava} annotation to hide it from the view menu. Hereby preventing the user to access it. No problem, we will now build an action that will launch it as a supplementary view. 



\subsection{The TrackMateActionFactory interface.}
%-------------------------------------------------

Again, the action behavior and its integration in TrackMate are split in two classes. The behavior is described by the  \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/action/TrackMateAction.java}{TrackMateAction} interface. The integration mechanism is controlled by the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/action/TrackMateActionFactory.java}{TrackMateActionFactory} interface, which extends the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/TrackMateModule.java}{TrackMateModule} interface. 



\subsubsection{SciJava parameters recapitulation.}
%-------------------------------------------------

There is not much to say about the factory itself. Ii is the class that must be annotated with 
\begin{lstlisting}[language=java]
@Plugin( type = TrackMateActionFactory.class )
\end{lstlisting}

All the SciJava annotation parameters apply, and they have the following meaning:

\begin{myitemize}
	\item The \texttt{enabled = true/false} parameter is used to control whether the action is enabled or not. A disabled action is not even instantiated.
  \item The \texttt{visible = true/false} parameter determines whether the action is listed in the action panel. If false, the action factory is instantiated but the corresponding action will not be listed in the panel, preventing any use. 
	\item The \texttt{priority = double} parameter is used here just to determine the order in which the action items appear in the list. High priorities are listed last.
\end{myitemize}



\subsubsection{Action factory methods.}
%--------------------------------------

As of \wikilink{TrackMate}{TrackMate} version 2.2.0 (March 2014), actions are the only TrackMate modules that use the \texttt{getIcon()} method. The icon is then displayed in the action list, next to the action name. That's it for the \texttt{TrackMateModule} part.

The method specific to actions is more interesting:
\begin{lstlisting}[language=java]
@Override
public TrackMateAction create( final TrackMateGUIController controller )
\end{lstlisting}

This means that when we create our specific action, we have access to the some of GUI context through the controller. We therefore have to check its \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/gui/TrackMateGUIController.java}{API} to know what we can get. It gives us access to:
\begin{myitemize}
  \item The GUI window itself (\texttt{public TrackMateWizard getGUI()}), that we can use as parent for dialogs, wild live GUI editing...
  \item The trackmate plugin (\texttt{public TrackMate getPlugin()}), hereby the model and settings objects.
  \item The selection model (\texttt{public SelectionModel getSelectionModel()})
  \item Even the GUI model (\texttt{public TrackMateGUIModel getGuimodel()})
  \item And all the providers that manage the modules of TrackMate.
\end{myitemize}
So you can pretty well mess stuff with the controller, but it gives us access to mainly everything. In our case, we do not need much. Here is the code for our simple event logger launcher: 

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.action;

import javax.swing.ImageIcon;

import org.scijava.plugin.Plugin;

import fiji.plugin.trackmate.action.TrackMateAction;
import fiji.plugin.trackmate.action.TrackMateActionFactory;
import fiji.plugin.trackmate.gui.TrackMateGUIController;

@Plugin( type = TrackMateActionFactory.class )
public class LaunchEventLoggerActionFactory implements TrackMateActionFactory
{

	private static final String INFO_TEXT = "<html>This action will launch a new event logger, that uses the ImageJ log window to append TrackMate events.</html>";
	private static final String KEY = "LAUNCH_EVENT_LOGGER";
	private static final String NAME = "Launch the event logger";

	@Override
	public String getInfoText()
	{
		return INFO_TEXT;
	}

	@Override
	public ImageIcon getIcon()
	{
		return null; // No icon for this one.
	}

	@Override
	public String getKey()
	{
		return KEY;
	}

	@Override
	public String getName()
	{
		return NAME;
	}

	@Override
	public TrackMateAction create( final TrackMateGUIController controller )
	{
		return new LaunchEventLoggerAction( controller.getPlugin().getModel(), controller.getSelectionModel() );
	}

}
\end{lstlisting}

Nothing complicated.


\subsection{The TrackMateAction interface.}
%------------------------------------------


This interface is just made of two methods: 

\begin{lstlisting}[language=java]
public void execute(TrackMate trackmate);
public void setLogger(Logger logger);
\end{lstlisting}

The \texttt{execute} method is the one triggered by the user when he clicks the \smallimg{Icon_play.png} \textbf{Execute} button. It receives a TrackMate instance that can be of use. In our case, as you saw in the factory class, we got the model and selection model through the controller.
The other method is used to pass a logger instance that is specific to the action panel in the GUI. All messages and updates sent to this logger will be shown on the action panel.
Here is how this translates simply in a simple launcher:

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.action;

import plugin.trackmate.examples.view.EventLoggerView;
import fiji.plugin.trackmate.Logger;
import fiji.plugin.trackmate.Model;
import fiji.plugin.trackmate.SelectionModel;
import fiji.plugin.trackmate.TrackMate;
import fiji.plugin.trackmate.action.TrackMateAction;

public class LaunchEventLoggerAction implements TrackMateAction
{

	private final SelectionModel selectionModel;

	private final Model model;

	private Logger logger;

	public LaunchEventLoggerAction( final Model model, final SelectionModel selectionModel )
	{
		this.model = model;
		this.selectionModel = selectionModel;
	}

	@Override
	public void execute( final TrackMate trackmate )
	{
		logger.log( "Launching a new event logger..." );
		final EventLoggerView view = new EventLoggerView( model, selectionModel );
		view.render();
		logger.log( " Done.\n" );
	}

	@Override
	public void setLogger( final Logger logger )
	{
		this.logger = logger;
	}
}
\end{lstlisting}



\subsection{Wrapping up.}
%------------------------

And here are the results:

\screenshotB{TrackMate_CustomAction_1.png}

You can imagine a lot of applications for Actions. Since they give you access to most of the plugin context, you can basically plug anything there. The one limitation is that it does not fit perfectly in the existing GUI: actions just appear as items in a drop-down list. But in most cases it does not matter much. Actions are very useful to quickly graft a piece of new functionality on TrackMate.

This concludes this tutorial, which was pretty quick and simple. This is unfortunately the last time in this series that things are simple and short. The next tutorial will be about implementing a custom detector, which will turn to be quite complicated for apparently wrong reasons.





















































%----------------------------------------------------------------------------------------
%                                CUSTOM DETECTION ALGORITHM.
%----------------------------------------------------------------------------------------




\section{How to write your own detection algorithm for TrackMate.}
%-----------------------------------------------------------------



\subsection{Introduction.}
%-------------------------
Welcome to the most useful and also unfortunately the hardest part in this tutorial series on how to extend \wikilink{TrackMate}{TrackMate} with custom modules. 

The detection algorithms in TrackMate are basic: they are all based or approximated from the \wikilink{wikipedia:Blob detection#The_Laplacian_of_Gaussian}{Laplacian of Gaussian} technique. They work well even in the presence of noise for round or spherical and well separated objects. As soon as you move away from these requirements, you will feel the need to implement your own custom detector. 

This is the subject of this tutorial, which will appear denser than the previous ones. Not because implementing a custom detection algorithm is difficult. It \textit{is} difficult, even very difficult if you are not familiar with the \wikilink{ImgLib2}{ImgLib2}  library. But we will skip this difficulty here by not making a true detector, but just a dummy one that returns detections irrespective of the image content. This involved task is left to your Java and ImgLib2 skills. 

No, this tutorial will be difficult because contrary to the previous ones, we need to do a lot of work even for just a dummy detector. The reason for this comes from our desire to have a nice and tidy integration in TrackMate. The custom detector we will write will be a first-class citizen of TrackMate, and this means several things: Not only it must be able to provide a proper detection, but it must also

\begin{myitemize}
	\item offer the user some configuration options, in a nice GUI;
	\item check that the user entered meaningful detection parameters;
	\item enable the saving and loading of these parameters to XML.
\end{myitemize}
We did not have to care when implementing a \wikilink{How to write custom actions for TrackMate}{custom action}, but now we do.
Let's get started with the easiest part, the detection algorithm.




\subsection{The SpotDetector interface.}
%---------------------------------------




\subsubsection{A detector instance operates on a single frame.}
%--------------------------------------------------------------

The detection part itself is implemented in a class that implements the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/SpotDetector.java}{SpotDetector} interface. Browsing there, you will see that it is just a specialization of an output algorithm from \wikilink{ImgLib2}{ImgLib2}. We are required to spit out a \texttt{List<Spot>} that represents the list of detection (one \texttt{Spot} per detection) for a \textbf{single frame}. 
This is important: an instance of your detector is supposed to work on a single frame. \TrackMate will generate as many instances of the detector per frame it has to operate on. This facilitates development, but also multithreading: TrackMate fires one detector per thread it has access to, and this is done without you having to worry about it. TrackMate will bundle the outputs of all detectors in a thread-safe manner.

It is the work of the detector factory to provide each instance with the data required to segment a specific frame. But we will see how this is done below. 


\subsubsection{A SpotDetector \textit{can be} multithreaded.}
%------------------------------------------------------------

So TrackMate offers you a turnkey multithreaded solution: If you have a computer with 12 cores and 50 frames to segment, TrackMate will fire 12 SpotDetectors at once and process them concurrently. 

But let's say that you have 24 cores and only 6 frames to segment. You can exploit this situation by letting your concrete instance of SpotDetector implement the ImgLib2 \otherlink{https://github.com/imglib/imglib/blob/master/algorithms/core/src/main/java/net/imglib2/algorithm/MultiThreaded.java}{MultiThreaded} interface. In that case, TrackMate will still fire 6 SpotDetector instances (one for each frame), but will allocate 4 threads to each instance, and get an extra kick in speed. 

Of course, you have to devise a clever multithreading strategy to operate concurrently on a single frame. For instance, you could divide the image into several blocks and process them in parallel. Or delegate to sub-algorithms that are multithreaded; check for instance the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/LogDetector.java}{LogDetector} code.




\subsubsection{Detection results are represented by Spots.}
%----------------------------------------------------------

\otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/Spot.java}{Spots} are used to represent detection results: one detection = one spot. By convention, a detection algorithm must provide \textit{at least} the following numerical feature to each spot:

\begin{myitemize}

	\item The X, Y, Z coordinates, obviously. What is not that obvious is that TrackMate uses only image coordinates. This means that if your image has a physical calibration in m (\eg 0.2 m/pixels in X,Y), the spot coordinates must be in m<wiki><ref>The reason behind this is that TrackMate wants to break free of the source data. Keeping all the coordinates in physical units allow exchanging and working on results without having to keep a reference to the original image.</ref></wiki><latex>\footnote{The reason behind this is that TrackMate wants to break free of the source data. Keeping all the coordinates in physical units allow exchanging and working on results without having to keep a reference to the original image.}</latex>. If you have just a 2D image, use 0 for the Z position, but it must not be omitted.

	\item A quality value, that reflects the quality of the detection itself. It must be a real, positive number, that reflects how confident your detection algorithm is that the found detection is not spurious. The larger the more confident.
	
	\item The spot radius, representing in physical units, the approximate size of the image structure that was detected. TrackMate default detectors do not have an automatic size detection feature, so they ask the user what is the most likely size of the structures they should detect, tune themselves to this size, and set all the radius of the detections to be the one entered by the user.

\end{myitemize}
Any omission will trigger errors at runtime. 





\subsubsection{A dummy detector that returns spiraling spots.}
%-------------------------------------------------------------

For this tutorial we will build a dummy detector, that actually fully ignores the image content and just create spots that seem to spiral out from the center of the image. A real detector would require you to hone your \wikilink{ImgLib2}{ImgLib2} skills; check the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/LogDetector.java}{LogDetector} code for an example. 

Below is the source code for the dummy detector. You can also find it \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/detector/SpiralDummyDetector.java}{online}. Let's comment a bit on this:



\paragraph{The type parameter \texttt{< T extends RealType< T > \& NativeType< T >>}.}
%-----------------------------------------------------------------------------------


Instances of SpotDetector are parametrized with a generic type \texttt{T} that must extends \otherlink{https://github.com/imglib/imglib/blob/master/core/src/main/java/net/imglib2/type/numeric/RealType.java}{RealType} and \otherlink{https://github.com/imglib/imglib/blob/master/core/src/main/java/net/imglib2/type/NativeType.java}{NativeType}. These are the bounds for all the scalar types based on native types, such us \texttt{float}, \texttt{int}, \texttt{byte}, \etc. 
This is the type of the image data we are to operate on.



\paragraph{The constructor.}
%---------------------------

Since the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/SpotDetector.java}{SpotDetector} interface gives little constraint on inputs, all of them must be provided at construction time in the constructor. Keep in mind that we have one instance per frame, so we must know what frame we are to process. 

Normal detectors would be fed with a reference to the image data \textit{for this very single frame}. Here we do not care for image content, so it is not there. But we will speak of this more when discussing the factory. 

Because TrackMate can also be tuned to operate only on a ROI, the instance receives an \otherlink{https://github.com/imglib/imglib/blob/master/core/src/main/java/net/imglib2/Interval.java}{Interval} that represent the bounding box \textbf{in pixel coordinates} of the ROI the user selected. Here, we just use it to center the spirals. 

Because we must store the \textit{physical coordinates} in the spots we create, we need a calibration array to convert pixel coordinates to physical ones. That is the role of the \texttt{double[] calibration } array, and it contains the pixel sizes along X, Y and Z.



\paragraph{The Algorithm methods.}
%---------------------------------

\texttt{checkInput()} checks that the parameters passed are OK prior to processing, and returns \texttt{false} if they are not. \texttt{process()} does all the hard work, and return \texttt{false} if something goes wrong. 
If any of these two methods returns \texttt{false}, you are expected to document what went wrong in an error message that can be retrieved through \texttt{getErrorMessage()}.



\paragraph{The OutputAlgorithm method.}
%--------------------------------------

This one just asks us to return the results as a list of spots. It must be a field of your instance, that is ideally instantiated and built in the \texttt{process()} method. The \texttt{getResult()} method exposes this list. 



\paragraph{The Benchmark method.}
%--------------------------------

Well, we just want to know how much time it took. Note that all of these are the usual suspects of an ImgLib2 generic algorithm, so they should not confuse you.



\paragraph{The code itself.}
%---------------------------

Here is the code listing:

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.detector;

import java.util.ArrayList;
import java.util.List;

import net.imglib2.Interval;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import fiji.plugin.trackmate.Spot;
import fiji.plugin.trackmate.detection.SpotDetector;

public class SpiralDummyDetector< T extends RealType< T > & NativeType< T >> implements SpotDetector< T >
{

	private static final double RADIAL_SPEED = 3d; // pixels per frame

	// radians per frame
	private static final double ANGULAR_SPEED = Math.PI / 10;

	// in image units
	private static final double SPOT_RADIUS = 1d;

	/** The width if the ROI. */
	private final long width;

	/** The height if the ROI. */
	private final long height;

	/** The X coordinates of the ROI. */
	private final long xstart;

	/** The Y coordinates of the ROI. */
	private final long ystart;

	/** The pixel sizes in the 3 dimensions. */
	private final double[] calibration;

	/** The frame we operate in. */
	private final int frame;

	/** Holder for the results of detection. */
	private List< Spot > spots;

	/** Error message holder. */
	private String errorMessage;

	/** Holder for the processing time. */
	private long processingTime;

	/*
	 * CONSTRUCTOR
	 */

	public SpiralDummyDetector( final Interval interval, final double[] calibration, final int frame )
	{
		// Take the ROI box from the interval parameter.
		this.width = interval.dimension( 0 );
		this.height = interval.dimension( 1 );
		this.xstart = interval.min( 0 );
		this.ystart = interval.min( 1 );
		// We will need the calibration to convert to physical units.
		this.calibration = calibration;
		// We need to know what frame we are in.
		this.frame = frame;
	}

	/*
	 * METHODS
	 */

	@Override
	public List< Spot > getResult()
	{
		return spots;
	}

	@Override
	public boolean checkInput()
	{
		// Nothing to test, it's all good.
		return true;
	}

	@Override
	public boolean process()
	{
		final long start = System.currentTimeMillis();
		spots = new ArrayList< Spot >();

		/*
		 * This dummy detector creates spots that spiral out from the center of
		 * the specified ROI. It spits a new spiral every 10 frames.
		 */

		final int x0 = ( int ) ( width / 2 + xstart );
		final int y0 = ( int ) ( height / 2 + ystart );

		int t = frame;
		int nspiral = 0;
		while ( t >= 0 )
		{
			final double r = t * RADIAL_SPEED;
			final double phi0 = nspiral * Math.PI / 4;
			final double phi = t * ANGULAR_SPEED + phi0;

			// Spot in pixel coordinates.
			final double x = x0 + r * Math.cos( phi );
			final double y = y0 + r * Math.sin( phi );

			// But we want to create spots in image coordinates:
			final double xpos = x * calibration[ 0 ];
			final double ypos = y * calibration[ 1 ];
			final double zpos = 0d;

			// Create the spot.
			final Spot spot = new Spot( xpos, ypos, zpos, SPOT_RADIUS, 1d / ( nspiral + 1d ) );
			spots.add( spot );

			// Loop to another spiral.
			t = t - 10;
			nspiral++;
		}

		final long end = System.currentTimeMillis();
		this.processingTime = end - start;
		return true;
	}

	@Override
	public String getErrorMessage()
	{
		/*
		 * If something wrong happens while you #checkInput() or #process(),
		 * state it in the errorMessage field.
		 */
		return errorMessage;
	}

	@Override
	public long getProcessingTime()
	{
		return processingTime;
	}

}
\end{lstlisting}

And that's about it. 
Now for something completely different, we move to the factory class that instantiates this detector.







\subsection{The SpotDetectorFactory interface.}
%----------------------------------------------

The SpotDetectorFactory concrete implementation is the class that needs to be annotated with the \wikilink{SciJava}{SciJava} annotation. For instance:
\begin{lstlisting}[language=java]
@Plugin( type = SpotDetectorFactory.class )
public class SpiralDummyDetectorFactory< T extends RealType< T > & NativeType< T >> implements SpotDetectorFactory< T >
\end{lstlisting}

Note that we have to deal with the same type parameter than for the SpotDetector instance. 
We skip all the TrackMateModule methods we have seen over and over in this tutorial series. There is nothing new here, they all have the same role. The difficult and interesting parts are linked to what we introduced above. Basically we need to provide a logic for passing the raw image data, for saving/loading to XML, for querying the user for parameters, and checking them.



\subsubsection{Getting the raw image data.}
%------------------------------------------

Since the TrackMateModule concrete implementation must have a blank constructor, there must be another way to pass required arguments to factories. For SpotDetector factories, this role is played by the \texttt{setTarget} method:

\begin{lstlisting}[language=java]
@Override
public boolean setTarget( ImgPlus< T > img, Map< String, Object > settings )
\end{lstlisting}

The raw image data is returned as an \otherlink{https://github.com/imglib/imglib/blob/master/meta/src/main/java/net/imglib2/meta/ImgPlus.java}{ImgPlus}, that can be seen as the \wikilink{ImgLib2}{ImgLib2} equivalent of ImageJ1 \otherlink{https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/ImagePlus.java}{ImagePlus}. It contains the pixel data for all available dimensions (all X, Y, Z, C, T if any), plus the spatial calibration we need to operate in physical units. The concrete factory must be able to extract from this ImgPlus the data useful for the SpotDetectors it will instantiate, keeping in mind that each SpotDetector operates on one frame. 

The second argument is the settings map for this specific detector. It takes the shape of a map with string keys and object values, that can be cast to whatever relevant class. The concrete factory must be able to check that all the required parameters are there, and have a valid class, and to feed to the SpotDetector instances. We will see below that the user provides them through a configuration panel. 



\subsubsection{Getting detection parameters through a configuration panel.}
%--------------------------------------------------------------------------

For a proper TrackMate integration, we need to provide a means for users to tune the detector they chose. And since TrackMate was built first to be used through a GUI, we need to create a GUI element for this task: a configuration panel. The class that does that in TrackMate is \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/gui/ConfigurationPanel.java}{ConfigurationPanel}. It is an abstract class that extends JPanel, and that adds two methods to display a settings map and return it. 

Each SpotDetectorFactory has its own configuration panel, which must be instantiated and returned through:
\begin{lstlisting}[language=java]
@Override
public ConfigurationPanel getDetectorConfigurationPanel( Settings settings, Model model )
\end{lstlisting}

The GUI panel has access to the model and settings objects, and can therefore display some relevant information.

This is a difficult part because you have to write a GUI element. GUIs are excruciating long and painfully hard to write, at least if you want to get them right. Check the configuration panel of the  \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/gui/panels/detector/LogDetectorConfigurationPanel.java}{LoG detector} for an example.



\subsubsection{Checking the validity of parameters.}
%---------------------------------------------------

There is a layer of methods that allows checking for the parameter validity. Normally you don't need to, since you write the configuration panel for the detector you also develop, but I have found this to be useful to find errors early. Parameter checking is done after user edition, loading and saving.

Three methods are at play: 
\begin{lstlisting}[language=java]
public Map< String, Object > getDefaultSettings();
public boolean checkSettings( Map< String, Object > settings );
public String getErrorMessage();
\end{lstlisting}

The \texttt{getDefaultSettings()} method return a new settings map initialized with default values. It must contain all the required parameter keys, and nothing more. The \texttt{checkSettings()} method does the actual parameter checking. It must check that all the required parameters are there, that they have the right class, and that there is no spurious mapping in the map. Should any of these defects be found, it returns \texttt{false}. Finally, \texttt{getErrorMessage()} should return a meaningful error message if the check failed. 


\subsubsection{Saving to and loading from XML.}
%----------------------------------------------

TrackMate tries to save as much information as possible when saving to XML. The save file should contain at the very least the tracking results, but it should also include the parameters that help creating these results. The detection algorithm parameters should therefore be included. 

You have to provide the means to save and load this parameters, since they are specific to the detector you write. This is done through the two methods: 

\begin{lstlisting}[language=java]
public boolean marshall( Map< String, Object > settings, Element element );
public boolean unmarshall( Element element, Map< String, Object > settings );
\end{lstlisting}



\paragraph{Marshalling.}
%-----------------------

Marshalling is the action of serializing a java object to XML. TrackMate relies on the \otherlink{http://www.jdom.org/}{JDom library} to do so, and it greatly simplifies the task.

The settings map that the \texttt{marshall} method receives is the settings map to save. You can safely assume it has been successfully checked. The element parameter is a \otherlink{http://www.jdom.org/docs/apidocs/org/jdom2/Element.html}{JDom element}, and it must contain eveything you want to save from the detector, as attribute or child elements. Here is what you must put in it:

\begin{myitemize}

	\item You must at the very least set an attribute that has for key \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/DetectorKeys.java\#L14}{\texttt{"DETECTOR\_NAME"}} and value the SpotDetectorFactory key (the one you get with the \texttt{getKey()}) method. This will be used in turn when loading from XML, to retrieve the right detector you used. 

	\item If something goes wrong when saving, then the \texttt{marshall} method must return \texttt{false}, and you must provide a meaningful error message for the \texttt{getErrorMessage()} method.

	\item Everything else is pretty much up to you. There is a \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/io/IOUtils.java\#L383}{helper method in IOUtils} that you can use to serialize single parameters. Check the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/LogDetectorFactory.java\#L161}{LogDetectorFactory marshall method} for an example. 

\end{myitemize}



\paragraph{Unmarshalling.}
%-------------------------

Unmarshalling is just the other way around. You get a map that you must first clear, then build from the JDom element specified. You can safely assume that the XML element you get was built from the \texttt{marshall} method of the same SpotDetectorFactory. TrackMate makes sure the right \texttt{unmarshall} method is called. 

There are a few help methods around to help you with reading from XML. For instance, check all the \texttt{read*Attribute} of the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/io/IOUtils.java}{IOUtils} class. It is also a good idea to call the \texttt{checkSettings} method with the map you just built.

Check again the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/detection/LogDetectorFactory.java\#L173}{LogDetectorFactory unmarshall method} for an example.



\subsubsection{Instantiating spot detectors.}
%--------------------------------------------

And finally, the method that gives its name to this factory:

\begin{lstlisting}[language=java]
public SpotDetector< T > getDetector( Interval interval, int frame )
\end{lstlisting}

This will be called repeatedly by TrackMate to generate as many SpotDetector instances as there is frames in the raw data to segment. The two parameters specify the ROI the user wants to operate on as an \otherlink{https://github.com/imglib/imglib/blob/master/core/src/main/java/net/imglib2/Interval.java}{Imglib2 interval}, and the target frame. So you need to process and bundle:

\begin{myitemize}
	\item this interval and this frame;
	\item the raw image data and settings map  received from the \texttt{setTarget} method
in the parameters required to instantiate a new SpotDetector. 
\end{myitemize}
Because the dummy example we use in this tutorial is not very enlightening, we copy here the code from the LogDetectorFactory. It shows how to extract parameters from a settings map, and how to access the relevant data frame in a possibly 5D image:

\begin{lstlisting}[language=java]
	@Override
	public SpotDetector< T > getDetector( final Interval interval, final int frame )
	{
		final double radius = ( Double ) settings.get( KEY_RADIUS );
		final double threshold = ( Double ) settings.get( KEY_THRESHOLD );
		final boolean doMedian = ( Boolean ) settings.get( KEY_DO_MEDIAN_FILTERING );
		final boolean doSubpixel = ( Boolean ) settings.get( KEY_DO_SUBPIXEL_LOCALIZATION );
		final double[] calibration = TMUtils.getSpatialCalibration( img );

		RandomAccessible< T > imFrame;
		final int cDim = TMUtils.findCAxisIndex( img );
		if ( cDim < 0 )
		{
			imFrame = img;
		}
		else
		{
			// In ImgLib2, dimensions are 0-based.
			final int channel = ( Integer ) settings.get( KEY_TARGET_CHANNEL ) - 1;
			imFrame = Views.hyperSlice( img, cDim, channel );
		}

		int timeDim = TMUtils.findTAxisIndex( img );
		if ( timeDim >= 0 )
		{
			if ( cDim >= 0 && timeDim > cDim )
			{
				timeDim--;
			}
			imFrame = Views.hyperSlice( imFrame, timeDim, frame );
		}
		final LogDetector< T > detector = new LogDetector< T >( imFrame, interval, calibration, radius, threshold, doSubpixel, doMedian );
		detector.setNumThreads( 1 );
		return detector;
	}
\end{lstlisting}




\subsubsection{The code for the dummy spiral generator factory.}
%---------------------------------------------------------------

And here is the full code for this tutorial example. It is the ultimate simplification of a SpotDetectorFactory, and was careful to strip anything useful by first ignoring the image content, second by not using any parameter. You can also find it \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/detector/SpiralDummyDetectorFactory.java}{online}.

\begin{lstlisting}[language=java]
package plugin.trackmate.examples.detector;

import ij.ImageJ;
import ij.ImagePlus;

import java.util.Collections;
import java.util.Map;

import javax.swing.ImageIcon;

import net.imglib2.Interval;
import net.imglib2.meta.ImgPlus;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;

import org.jdom2.Element;
import org.scijava.plugin.Plugin;

import fiji.plugin.trackmate.Model;
import fiji.plugin.trackmate.Settings;
import fiji.plugin.trackmate.TrackMatePlugIn_;
import fiji.plugin.trackmate.detection.SpotDetector;
import fiji.plugin.trackmate.detection.SpotDetectorFactory;
import fiji.plugin.trackmate.gui.ConfigurationPanel;
import fiji.plugin.trackmate.util.TMUtils;

@Plugin( type = SpotDetectorFactory.class )
public class SpiralDummyDetectorFactory< T extends RealType< T > & NativeType< T >> implements SpotDetectorFactory< T >
{

	static final String INFO_TEXT = "<html>This is a dummy detector that creates spirals made of spots emerging from the center of the ROI. The actual image content is not used.</html>";
	private static final String KEY = "DUMMY_DETECTOR_SPIRAL";
	static final String NAME = "Dummy detector in spirals";

	private double[] calibration;

	private String errorMessage;

	@Override
	public String getInfoText()
	{
		return INFO_TEXT;
	}

	@Override
	public ImageIcon getIcon()
	{
		return null;
	}

	@Override
	public String getKey()
	{
		return KEY;
	}

	@Override
	public String getName()
	{
		return NAME;
	}

	@Override
	public SpotDetector< T > getDetector( final Interval interval, final int frame )
	{
		return new SpiralDummyDetector< T >( interval, calibration, frame );
	}

	@Override
	public boolean setTarget( final ImgPlus< T > img, final Map< String, Object > settings )
	{
		/*
		 * Well, we do not care for the image at all. We just need to get the
		 * physical calibration and there is a helper method for that.
		 */
		this.calibration = TMUtils.getSpatialCalibration( img );
		// True means that the settings map is OK.
		return true;
	}

	@Override
	public String getErrorMessage()
	{
		/*
		 * If something is not right when calling #setTarget (i.e. the settings
		 * maps is not right), this is how we get an error message.
		 */
		return errorMessage;
	}

	@Override
	public boolean marshall( final Map< String, Object > settings, final Element element )
	{
		/*
		 * This where you save the settings map to a JDom element. Since we do
		 * not have parameters, we have nothing to do.
		 */
		return true;
	}

	@Override
	public boolean unmarshall( final Element element, final Map< String, Object > settings )
	{
		/*
		 * The same goes for loading: there is nothing to load.
		 */
		return true;
	}

	@Override
	public ConfigurationPanel getDetectorConfigurationPanel( final Settings settings, final Model model )
	{
		// We return a simple configuration panel.
		return new DummyDetectorSpiralConfigurationPanel();
	}

	@Override
	public Map< String, Object > getDefaultSettings()
	{
		/*
		 * We just have to return a new empty map.
		 */
		return Collections.emptyMap();
	}

	@Override
	public boolean checkSettings( final Map< String, Object > settings )
	{
		/*
		 * Since we have no settings, we just have to test that we received the
		 * empty map. Otherwise we generate an error.
		 */
		if ( settings.isEmpty() ) { return true; }
		errorMessage = "Expected the settings map to be empty, but it was not: "+settings+'\n';
		return false;
	}
}
\end{lstlisting}



\subsection{Wrapping up.}
%------------------------

This was a lot of information and a lot of coding for a single piece of functionality. But all of these painful methods make your detector a first-class citizen of TrackMate. "Native" detectors use the exact same logic.
Here is what our dummy example looks, after tracking the spots this it creates.

\screenshotA{TrackMate_CustomDetector_01.png}

<wiki>
== References ==

<references/>

[[Category:Tutorials]]
</wiki>































%----------------------------------------------------------------------------------------
%                               CUSTOM PARTICLE-LINKING ALGORITHM.
%----------------------------------------------------------------------------------------





















\section{How to write your own particle-linking algorithm for TrackMate.}
%------------------------------------------------------------------------



\subsection{Introduction.}
%-------------------------
This last part on particle-linking modules concludes the series of tutorials on extending \TrackMate. The most difficult modules to create are spot detectors, which was the subject of the previous section. Particle-linking modules, or trackers, are a little bit less complicated. 
However, you still need to understand how we store and manipulate links in TrackMate, and this implies very briefly introducing mathematical graphs.



\subsection{Simple, undirected graphs.}
%---------------------------------------

TrackMate stores the results of the detection step as spots in a \otherlink{http://fiji.sc/javadoc/fiji/plugin/trackmate/SpotCollection.html}{SpotCollection}. The tracking results are mainly links between these spots so we needed a structure to hold them. We went for the most general one, and picked a mathematical graph.

\otherlink{http://en.wikipedia.org/wiki/Graph_(mathematics)}{Mathematical graphs} are mathematical structures that hold objects (\textbf{vertices}) and links between them (\textbf{edges}, we will use the two terms interchangeably). TrackMate relies specifically on a specialization: it uses an undirected, simple weighted graph.

\begin{myitemize}
	\item Undirected means that a link between A and B is the same as a link between B and A. There is no specific direction and it cannot be exploited. However, you will see that the API offers specific tools that can fake a direction. Indeed, since we deal mainly with time-lapse data, we would like to make it possible to say that we iterate a graph following the time direction.
	\item Simple is not related to the efforts that must be made to grasp this mathematical field, but to the fact that there can be only 1 or no link between two spots, and that we do not authorize a link going from one spots to this same spot (no loop).
	\item Weighted means that each link has a numerical value, called weight, associated to it. We use it just to store some of the results of the tracking algorithm, but it has no real impact on TrackMate.
\end{myitemize}
This restrictions do not harm the generality of what you can represent in Life Science with this. You can still have the classical links you find in typical time-lapse experiment:
\begin{myitemize}
	\item Following a single object over time: 
	\begin{verbatim}A0 - A1 - A2 - A3 - ...\end{verbatim}

	\item A cell division:
	\begin{verbatim}A0 - A1 -+- B2 - B3 - ...
         |
         +- C2 - C3 - ...\end{verbatim}
	\item But also anything fusions, tripolar divisions, and a mix of everything in the same model.
\end{myitemize}



\subsection{Graphs in TrackMate.}
%--------------------------------

On a side note, this is important if you plan to build analysis tools for TrackMate results. TrackMate philosophy is to offer managing the most general case (when it comes to linking), but your analysis tools might require special use cases. 
\begin{myitemize}
	\item For instance, when you are tracking vesicles that do not fuse nor split, you just have a linear data structure (an array of objects for each particle). 
	\item When you follow a cell lineage, you have a  \otherlink{http://en.wikipedia.org/wiki/Tree_(data_structure)}{rooted mathematical tree}. 
	\item And if all cells divide in two daughters, then you have a \otherlink{http://en.wikipedia.org/wiki/Binary_tree}{rooted binary tree}. 
\end{myitemize}
They all are specialization of the simple graph, and offer special tools that can be very useful. But \textit{TrackMate assumes none of these specializations}. It stores and manipulate a graph.

Since we are Java coders, we use a Java library to manipulate these graphs, and for this we rely on the excellent \otherlink{http://jgrapht.org/}{JGraphT} library. Why a graph? Why not storing a list of successors and a list of predecessors for each spot? Or directly have a track object that would save some time on determining what are the tracks? Well, because a graph is very handy and simple to use when creating links. When you will write your own tracker, and found a link you want to add the model, the only thing you have to do is: \texttt{graph.addEdge(A, B)}. You don't have to care whether A belongs to a track and if yes to what track, you don't need to see the whole graph globally, you can just focus on the local link. Adding a link in the code is always very simple.

Then of course, you still need a way to know how many tracks are there in the model, and what are they made of. But this is the job of TrackMate. It offers the API that hides the graph and deals in track. This is done via a component of the model, the \otherlink{http://fiji.sc/javadoc/fiji/plugin/trackmate/TrackModel.html}{TrackModel}. But in the tracker we will not use this. We will be given a simple graph, and will have to flesh it out with spots and links between these spots. When the tracker completes, TrackMate will build and maintains a list of tracks from it. 

The price to pay for this simplicity is that - when tracking - it is not trivial to get the global information. For instance, it is easy to query whether a link exists between two spots, but the graph does not see the tracks directly. If you need them, you either have to build them from the graph, either have to maintain them locally. But more on this below. 



\subsection{Particle-linking algorithms in TrackMate.}
%------------------------------------------------------

We used the term \textit{tracker} since the beginning of this series, but the correct term for what we will build now is particle linking algorithm. Our particles are the visible spots resulting from the detection step, and the links will be the edges of the graph. A tracker could be defined as the full application that combines a particle detection algorithm with a particle linking algorithm.

In TrackMate, particle linking algorithms implements the \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/tracking/SpotTracker.java}{SpotTracker} interface. It is very simple. As explained in the docs, a SpotTracker algorithm is simply expected to create a new \otherlink{http://jgrapht.org/javadoc/index.html?org/jgrapht/graph/SimpleWeightedGraph.html}{SimpleWeightedGraph} from the SpotCollection given (using of course only the \textit{visible} spots). We use a simple weighted graph:

\begin{myitemize}
	\item Though the weights themselves are not used for subsequent steps, it is suggested to use edge weight to report the cost of a link.
	\item The graph is undirected, however, some link direction can be retrieved later on using the Spot.FRAME feature. The SpotTracker implementation does not have to deal with this; only undirected edges are created.
	\item Several links between two spots are not permitted.
	\item A link with the same spot for source and target is not allowed.
	\item A link with the source spot and the target spot in the same frame is not allowed. This must be enforced by implementations.
\end{myitemize}
There is also an extra method to pass a instance of \otherlink{http://fiji.sc/javadoc/fiji/plugin/trackmate/Logger.html}{Logger} to log the tracking process progresses. That's all. 



\subsection{A dummy example: drunken cell divisions.}
%----------------------------------------------------

There is already an example online that does \otherlink{https://github.com/fiji/TrackMate-examples/blob/master/src/main/java/plugin/trackmate/examples/tracker/RandomLinkingTracker.java}{random link creation}. Let's do something else, and build a tracker that links a spot to any two spots in the next frame (if they exist) as if it would go cell division as fast as it can.

Creating the class yields the following skeleton:
\begin{lstlisting}[language=java]
package plugin.trackmate.examples.tracker;

import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleWeightedGraph;

import fiji.plugin.trackmate.Logger;
import fiji.plugin.trackmate.Spot;
import fiji.plugin.trackmate.tracking.SpotTracker;

public class DrunkenCellDivisionTracker implements SpotTracker
{

	private SimpleWeightedGraph< Spot, DefaultWeightedEdge > graph;

	private String errorMessage;

	private Logger logger = Logger.VOID_LOGGER;

	@Override
	public SimpleWeightedGraph< Spot, DefaultWeightedEdge > getResult()
	{
		return graph;
	}

	@Override
	public boolean checkInput()
	{
		return true;
	}

	@Override
	public boolean process()
	{
		graph = new SimpleWeightedGraph<Spot,DefaultWeightedEdge>(DefaultWeightedEdge.class);
		return true;
	}

	@Override
	public String getErrorMessage()
	{
		return errorMessage;
	}

	@Override
	public void setNumThreads()
	{
		// Ignored. We do not multithreading here.
	}

	@Override
	public void setNumThreads( final int numThreads )
	{
		// Ignored.
	}

	@Override
	public int getNumThreads()
	{
		return 1;
	}

	@Override
	public void setLogger( final Logger logger )
	{
		// Just store the instance for later use.
		this.logger = logger;
	}
}
\end{lstlisting}

Parameters need to be passed to the class via its constructor. As for detectors, the factory we will build later will be in charge of getting these parameters. Of course, the most important one is the SpotCollection to track. In our case it will be the only one, as our dummy tracker do not have any settings. So we can have a constructor like this:
\begin{lstlisting}[language=java]
public DrunkenCellDivisionTracker( final SpotCollection spots )
	{
		this.spots = spots;
	}
\end{lstlisting}

then we exploit the SpotCollection in the \texttt{process()} method. Our strategy here is to loop over all the frames that have a content, and link each spot to two spots in the next frame - wherever they are - until there is either no source spots or no target spots left. The method looks like this:

\begin{lstlisting}[language=java]
@Override
public boolean process()
{
	graph = new SimpleWeightedGraph<Spot,DefaultWeightedEdge>(DefaultWeightedEdge.class);

	// Get the frames in order.
	final NavigableSet< Integer > frames = spots.keySet();
	final Iterator< Integer > frameIterator = frames.iterator();

	// Get all the visible spots in the first frame, and put them in a new
	// collection.
	final Iterable< Spot > iterable = spots.iterable( frameIterator.next(), true );
	final Collection< Spot > sourceSpots = new ArrayList< Spot >();
	for ( final Spot spot : iterable )
	{
		sourceSpots.add( spot );
	}

	// Loop over frames, and link the source spots to spots in the next
	// frame.
	double progress = 0;
	while ( frameIterator.hasNext() )
	{
		final Integer frame = frameIterator.next();
		final Iterator< Spot > it = spots.iterator( frame, true );
		SOURCE_LOOP: for ( final Spot source : sourceSpots )
		{
			/*
			 * Add the source to the graph, if it is not already done (doing
			 * it several time is not a problem: it's backed up by a Set).
			 */
			graph.addVertex( source );
			// Finds 2 targets.
			for ( int i = 0; i < 2; i++ )
			{
				if ( it.hasNext() )
				{
					final Spot target = it.next();
					// You must add it as vertex before creating the link.
					graph.addVertex( target );
					// This is how we create a link.
					final DefaultWeightedEdge edge = graph.addEdge( source, target );
					// We get the edge back, and set its weight through:
					if ( null != edge )
					{
						graph.setEdgeWeight( edge, 3.14 );
						/*
						 * Edge can be null if a link already exists between
						 * the two spots.
						 */
					}
				}
				else
				{
					break SOURCE_LOOP;
				}
			}
		}

		// Regenerate source list for next frame.
		sourceSpots.clear();
		for ( final Spot spot : spots.iterable( frame, true ) )
		{
			sourceSpots.add( spot );
		}

		progress += 1;
		logger.setProgress( progress / frames.size() );
	}
	return true;
}
\end{lstlisting}

So it's not really complicated. Which is good, because the complicated part, completely omitted here, is the one where you have to determine what links to create. This is where you Science should kick in. 




\subsection{The factory class.}
%------------------------------

Now that we have the clever part of the code (the one that does the actual linking), we need to deal with TrackMate integration. Like for the detection modules, this is done \textit{via} a factory class, named \otherlink{https://github.com/fiji/TrackMate/blob/master/src/main/java/fiji/plugin/trackmate/tracking/SpotTrackerFactory.java}{SpotTrackerFactory}. It is completely equivalent to the SpotDetectorFactory we saw in the \wikilink{How to write your own detection algorithm for TrackMate}{previous tutorial}, so I won't detail the common methods again.


The methods specific to the tracker are:

\begin{myitemize}

	\item
	\begin{lstlisting}[language=java]
	public SpotTracker create( final SpotCollection spots, final Map< String, Object > settings );
	\end{lstlisting}
	This method instantiates the actual tracker class. You can see that it received the SpotCollection and a settings map. This method is expected to unpack this map and extract the actual parameters need to instantiate the tracker.
	Note that contrary to the detector factory, TrackMate calls this method only once for a tracking process. It does not generate a tracker per frame. So it is actually simpler than for detection: a tracker instance is expected to solve the tracking problem for the whole model at once. Therefore, there is no need for a \texttt{setTarget()} method, like previously.

	\item
	\begin{lstlisting}[language=java]
	public ConfigurationPanel getTrackerConfigurationPanel( final Model model );
	\end{lstlisting}	
	This method should generate a GUI panel to request tracking parameters from the user. Completely similar to the detection modules.

	\item \texttt{marshall} and \texttt{unmarshall}. Save to and retrieve from XML, like previously. 

	\item
	\begin{lstlisting}[language=java]
	public String toString( final Map< String, Object > sm );
	\end{lstlisting}
	Used to pretty-print the settings map specific to this tracker.

	\end{myitemize}
The rest is classic. Here is what it looks like for our tracker:

\screenshotC{TrackaMateExample_RandomCellDivision.png}

\noindent TrackMate recognize there were two tracks. You did not have to worry about that. 


\subsection{Wrapping up.}
%------------------------

The full code, as well as the code for another tracker example can be found on \otherlink{https://github.com/fiji/TrackMate-examples/tree/master/src/main/java/plugin/trackmate/examples/tracker}{github}. And this concludes flatly our series of tutorials on how to extend TrackMate. Go forth now, and bend it to your needs; it is \textit{your} tool.























%----------------------------------------------------------------------------------------
%                                GLOBAL BIBLIORAPHY.
%----------------------------------------------------------------------------------------



<latex>
\ifdefined\wtexpart
\else
\newpage
\begin{thebibliography}{99}

	\bibitem{lindeberg} Lindeberg, T. \textit{Feature detection with automatic scale selection.}
International Journal of Computer Vision 30 (2) (1998) pp 77--116. 
	
	\bibitem{lowe} Lowe, D.G. \textit{Distinctive image features from scale-invariant keypoints}, 
	International Journal of Computer Vision, 60, 2 (2004), pp. 91-110.
	
	\bibitem{otsu} Otsu, N., \textit{A threshold selection method from gray-level histograms}, in IEEE 
	Transactions on Systems, Man, and Cybernetics, vol. 9, no. 1, pp. 62-66, Jan. 1979.

	\bibitem{jaqaman}  \otherlink{
http://www.nature.com/nmeth/journal/v5/n8/full/nmeth.1237.html}{Jaqaman, K. et al.}, \textit{Robust single-particle trac\-king in live-cell time-lapse se\-quences}, Nat Me\-thods. 2008 Aug;5(8):695-702.

	\bibitem{crocker} \otherlink{http://physics.nyu.edu/grierlab/methods3c/methods3c.pdf}{Crocker and 
Grier.} \textit{Methods of Digital Video Microscopy for Colloidal Studies}, J Colloid Interf Sci (1996) vol. 179 (1) pp. 298-310.
	  
	\bibitem{bentley} Bentley, J. L.  \textit{Multidimensional binary search trees used for associative searching}, Communications of the ACM, vol. 18, no 9, 1975, p. 509-517.
	
	\bibitem{sage} \otherlink{http://bigwww.epfl.ch/publications/sage0501.pdf}{Sage, D. \etal}, \textit{Automatic tracking of Individual fluorescence Particles: Application to the study of chromosome dynamics}, IEEE Transactions on Image Processing, vol. 14, no. 9, pp. 1372-1383, September 2005.
	
	\bibitem{munkres} Munkres, J. \textit{Algorithms for the assignment and transportation problems}, 
	Journal of the Society for Industrial and Applied Mathematics, 5(1):3238, March 1957.

	\bibitem{isbi} \otherlink{http://www.nature.com/nmeth/journal/v11/n3/full/nmeth.2808.html}{Chenouard \etal}, \textit{Objective comparison of particle tracking methods}, Nature Methods, 2014.
	
	\bibitem{llt} Krull, A., \etal, \textit{A divide and conquer strategy for the maximum likelihood localization of low intensity objects}, Opt. Express 22, 210-228 (2014)
	
	
\end{thebibliography}


\end{document}
\fi
</latex>
% vim::set expandtab tabstop=4 softtabstop=2 shiftwidth=2 ft=tex:
