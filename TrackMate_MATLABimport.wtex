\section{Importing and analyzing TrackMate data in MATLAB.}
%----------------------------------------------------------

We document here the functions shipped with Fiji that allows for
importing TrackMate data in MATLAB. These functions use amongst other
things the MATLAB classes \texttt{table} and \texttt{digraph}, introduced respectively
with versions R2013b and R2015b, so a recent version of MATLAB is
required to use them. Also, end-users should have some notions of MATLAB
and basic undertanding of mathematical graphs to take full advantage of
this documentation.

For most tracking applications, importing tracking results is easy, as
long as the tracks are linear tracks. If the tracks do not have split or
merge events, then single tracks can be represented by a linear array,
for instance containing the particle positions or indices. Things are
much more complicated when a track can divide in two or more components,
or inversely merge with another track. A track cannot be represented
anymore by linear arrays. This is the case for TrackMate, as its data
model permits split and merge events.

Here we document the various ways of importing TrackMate data in MATLAB,
how to deal with complex tracks and show examples of basic analysis and
visualisation of tracks in MATLAB.



\subsection{Installation of TrackMate functions for MATLAB.}
%-----------------------------------------------------------

The Fiji applications ships up to date MATLAB functions that - amonsgt
other things - deal with TrackMate import. They are contained in the
\texttt{scripts} folder of the \texttt{Fiji.app} installation:

\begin{lstlisting}[language=matlab]
   ls ~/Development/Fiji.app/scripts
   ImageJ.m			Miji.m				trackmateEdges.m
   InstallJava3D.m			Miji_Test.m			trackmateFeatureDeclarations.m
   IsJava3DInstalled.m		bfopen.m			trackmateGraph.m
   Matlab3DViewerDemo_1.m		copytoImg.m			trackmateImageCalibration.m
   Matlab3DViewerDemo_2.m		copytoImgPlus.m			trackmateSpots.m
   Matlab3DViewerDemo_3.m		copytoMatlab.m
   Matlab3DViewerIntroduction.m	importTrackMateTracks.m
\end{lstlisting}

We are interested in the five \texttt{trackmate*.m} and \texttt{importTrackMateTracks.m}
functions. To make them available in your MATLAB sessions, you need to
add the \texttt{scripts} folder to your MATLAB path.

To do so, open the MATLAB path editor, and add the \texttt{scripts} folder to
it. The way to do it is best explained on the
\otherlink{http://mathworks.com/help/matlab/matlab_env/add-remove-or-reorder-folders-on-the-search-path.html}{MATLAB documentation website}.

Now check that the new functions are available from MATLAB:

\begin{lstlisting}[language=matlab]
>> which trackmateGraph
\end{lstlisting}

\begin{verbatim}
/Users/tinevez/Development/Matlab/functions/jy/trackmate/trackmateGraph.m
\end{verbatim}


\subsection{The simple case of linear tracks.}
%---------------------------------------------

In the case where your application only uses for linear tracks, you don't
need to deal with the aforementioned complexity and can rely on a simple
array data structure.

TrackMate has an action that exports data to a simplified XML file
containing the track. For in the action menu and look for the action
called \textbf{Export tracks to XML file}. This action will create a XML file
with a simple nomenclature, that resembles this:

\begin{verbatim}
   <?xml version="1.0" encoding="UTF-8"?>
   <Tracks nTracks="1959" spaceUnits="pixels" frameInterval="1.0" timeUnits="frames" 
           generationDateTime="Wed, 22 Jun 2016 16:33:25" from="TrackMate v3.3.0">
     <particle nSpots="10">
       <detection t="0" x="1710.2316032372419" y="1015.6860611330346" z="1613.7800548458297" />
       <detection t="1" x="1711.6515082603173" y="1017.4259447528594" z="1607.9224466590865" />
       <detection t="2" x="1708.333730185272" y="1015.602066751388" z="1609.974309410742" />
       <detection t="3" x="1707.7497692462046" y="1012.3362851983146" z="1614.9239783292087" />
       ... 
\end{verbatim}

Tracks are organized as \texttt{&lt;particle&gt;} element, and in each
% \texttt{&lt;particle&gt;} a spot takes the form of a \texttt{&lt;detection&gt;}
element, with T, X, Y and Z listed with their physical value.

This simple file format emerged from the
\otherlink{http://bioimageanalysis.org/track/}{ISBI Grand Challenge} on
single-particle tracking>. It is here to allow end-users to write simple
import filters for other languages.

Running this action on data wither split and merge events will \textbf{silently fail}
and generate a XML file that can be opened and imported, but with
missing links.

Importing such a file in MATLAB is done via the \texttt{importTrackMateTracks}
function:

\begin{lstlisting}[language=matlab]
>> file_path_tracks = 'Video_1_Tracks.xml';
>> tracks = importTrackMateTracks(file_path_tracks);
>> n_tracks = numel( tracks );
>> fprintf('Found %d tracks in the file.\n', n_tracks)
\end{lstlisting}

\begin{verbatim}
Found 55 tracks in the file.
\end{verbatim}

In MATLAB the tracks are stored in a cell array of matrices.

\begin{lstlisting}[language=matlab]
>> tracks( 1 )
\end{lstlisting}

\begin{verbatim}
ans = 

    [48x4 double]
\end{verbatim}

Each track is a $N \times 4$ matrix of double, one line per detection. On a
single line, the spot data is arranged as [T X Y Z ]:

\begin{lstlisting}[language=matlab]
>> tracks{1}(5, :)
\end{lstlisting}


\begin{verbatim}
ans =

    4.0000   80.7978   76.6681         0
\end{verbatim}

By default, time is reported in frame number, so it is an integer. Also,
spots have always a Z coordinate, even if the tracking was made in 2D.
The function \texttt{importTrackMateTracks} has two switches to change this
behavior. For instance:

\begin{lstlisting}[language=matlab]
clipZ   = true; % Remove Z coordinates, if you know you can.
scaleT  = true; % Use physical time for T. 
tracks = importTrackMateTracks(file_path_tracks, clipZ, scaleT);
tracks{1}(5, :)
\end{lstlisting}

\begin{verbatim}
ans =

    0.2400   80.7978   76.6681
\end{verbatim}

%%
The data file we used for this section has a physical frame interval, so
now T is in seconds. And since we clipped the Z coordinate, the tracks
are made of N x 3 matrices now. 

The metadata is stored in the file, and can be accessed as a secondary
output of the \texttt{importTrackMateTracks} function.

[ tracks, md ] = importTrackMateTracks(file_path_tracks, clipZ, scaleT);
md

%%
The data we used for this section came for the tracking of _Helicobacter
pylori_, a pathogenic bacteria responsible for ulcers amongst other
things. Their movement resembles this:

figure 
hold on
c = jet(n_tracks);
for s = 1 : n_tracks
    x = tracks{s}(:, 2);
    y = tracks{s}(:, 3);
    plot(x, y, '.-', 'Color', c(s, :))   
end
axis equal
xlabel( [ 'X (' md.spaceUnits ')' ] )
ylabel( [ 'Y (' md.spaceUnits ')' ] )

\subsection{Importing the spot feature table.}
There are many limitations with the later approach. The first one being
its inability to cope with complex tracks, as we said earlier. The second
one being that we did not import the spot features (mean intensity,
radius, etc) other than their position. To do so we have to move to more
complex functions that directly interact with TrackMate data files. 

The XML files are the ones in which TrackMate saves its tracking session,
when you press the \texttt{Save} button on the GUI. Their first lines resemble
this:

%    <?xml version="1.0" encoding="UTF-8"?>
%         <TrackMate version="3.3.0">
%         ...    

They are made of several XML elements, the most important one being the
% \texttt{Model}:

%   <Model spatialunits="pixel" timeunits="sec">

%%
The example file we use here comes from the lineage of a _C.elegans_
embryo over the first 3 hours of development post first anaphase. It is
made of four tracks: two for the polar bodies (PB1 and PB2), one for the
AB lineage and one for the P1 lineage. The AB and P1 lineages take the
shape of two tracks. In these tracks there are several cell divisions (5
for the AB lineage) so they are not linear and the approach of the
previous section will fail.

C.elegans lineage TrackMate data file.
file_path = '10-03-17-3hours.xml';

%%
The function \texttt{trackmateSpots} will import the visible spots of this file
as a MATLAB table. The \texttt{table} class is somewhat recent in MATLAB, so you
need at least MATLAB v2013b to have this function working.

The function basic syntax is the following:

[ spot_table, spot_ID_map ] = trackmateSpots( file_path );

%% 
We will speak about the second output argument \texttt{spot_ID_map} later. We
retrieve it now, for the functions that load a TrackMate file in MATLAB
can take quite some time to run, so you want to run them only once.

There is another optional input argument we did not speak about here. You
can pass as a second argument a cell array of strings containing the
names of the features you want to import. If this list is empty or if the
second argument is not present, all spot features are retrieved. Read the
help of the \texttt{trackmateSpots} to learn more about its full syntax.

%%
The table returned contains all the spot features by default, and spots
are listed by frame order:

spot_table( 1 : 6, { 'ID', 'name', 'FRAME' } )

%%
It is best to read the \texttt{table} documentation to take full advantage of
it. Nonetheless, here is a few things we can do with it. The lineage was
created with TrackMate, and the spot features we measured are imported
with name and units:

List a subset of features, there are 32 of them.
feature_subset = [ 1, 2, 13, 17, 22, 23, 24 ];

[   spot_table.Properties.VariableNames(feature_subset)
    spot_table.Properties.VariableDescriptions(feature_subset)
    spot_table.Properties.VariableUnits(feature_subset) ]

%% 
Values can be accessed directly with the feature name:

t = spot_table.FRAME;
t(10:16)

%%
Values can then be used to reslice through the table:

All spots in frame 10:
index = (t == 10);
spot_table(index, feature_subset)

%% 
You can redisplay the spot cloud in MATLAB:

x = spot_table.POSITION_X;
y = spot_table.POSITION_Y;
z = spot_table.POSITION_Z;

figure
plot3(x, y, z, 'k.')
axis equal
xlabel( [ 'X (' char(spot_table.Properties.VariableUnits(22)) ')' ] )
ylabel( [ 'Y (' char(spot_table.Properties.VariableUnits(23)) ')' ] )
zlabel( [ 'Z (' char(spot_table.Properties.VariableUnits(24)) ')' ] )

%% 
Notice that there is no time information on this plot, nor track
information. We just imported the spots so far, and there is not yet data
on how spots are linked. 

\subsection{Importing the edge track table.}
Edges - or links - are what assemble these spots in tracks. Each edge
represents a link from a spot (the source spot) to another (the target
spot). In TrackMate, edges are directed and oriented towards time: the
target has spot always a FRAME value strictly larger than the source
spot. Beyond this, there is no restrictions. A spot can be the source or
target of many links or none.

Edges have features too. These are values that make sense only for links,
such as velocity. The edge features are imported using a function similar
to the one for spots:

edge_map = trackmateEdges( file_path );


%% 
However here the data is not directly returned as a table but as a map of
table, one for each track:

What is the output class?
class( edge_map )

The track names are used as keys in the map:
track_names = edge_map.keys

How many tracks?
n_tracks = numel( track_names )

%%
The values of the map are edge feature tables:
ab_edges = edge_map('AB');
class( ab_edges )
ab_edges(1:6, 1:5)

%%
Feature names and units are imported too:
[   ab_edges.Properties.VariableNames
    ab_edges.Properties.VariableDescriptions
    ab_edges.Properties.VariableUnits ]


%% 
The \texttt{trackmateEdges} has a similar syntax to the \texttt{trackmateSpots}
function for optional input arguments. It is detailed in its help
section.

%%
There are two key features in these edge tables: the \texttt{SPOT_SOURCE_ID} and
the \texttt{SPOT_TARGET_ID}. They are the ones with which we can rebuild tracks
in TrackMate:

track_spot_IDs = cell( n_tracks, 1 );
for s = 1 : n_tracks
   
    track_name = track_names{s};
    edge_table = edge_map( track_name );
    track_spot_IDs{ s } = unique( [ 
        edge_table.SPOT_SOURCE_ID 
        edge_table.SPOT_TARGET_ID 
        ] );
    
end

%%
We now have the IDs of the spots that are in specified tracks. The
problem is that these IDs are spot IDs, and we have a spot table in which
the table row does not match the spot ID.

This is where the second output argument of the \texttt{trackmateSpots} function
is useful. \texttt{spot_ID_map} is a map that links spot IDs to row number in
the spot table. It is used as follow:

Retrieve the spot with ID:
spot_ID = 3087;
r = spot_ID_map( spot_ID )
spot_table( r, feature_subset )

%%
We can use it to retrieve the position of the spots in each track:

figure 
hold on
for s = 1 : n_tracks
   
    track_name = track_names{ s};
    track_spot_ID = track_spot_IDs{ s };
    
    % To extract several values all at once, we have to play with cell
    % arrays and the value map method:
    rows = cell2mat( spot_ID_map.values( num2cell(track_spot_ID) ) );    

    x = spot_table.POSITION_X( rows );
    y = spot_table.POSITION_Y( rows );
    z = spot_table.POSITION_Z( rows );
    
    % Plot the tracks by coloring spots.
    plot3( x, y, z, '.', 'DisplayName', track_name)
    
end

xlabel( [ 'X (' char(spot_table.Properties.VariableUnits(22)) ')' ] )
ylabel( [ 'Y (' char(spot_table.Properties.VariableUnits(23)) ')' ] )
zlabel( [ 'Z (' char(spot_table.Properties.VariableUnits(24)) ')' ] )
view(-15, 30)
axis equal
legend toggle

\subsection{Importing TrackMate data as a MATLAB graph.}
We are still missing one piece of information on the latest plot, which
is the connectivity between spot. We can retrieve it from the edges we
imported in the previous section, and accessing the \texttt{SPOT_SOURCE_ID} and
the \texttt{SPOT_TARGET_ID} features. A better solution is to directly import
the whole data as a MATLAB graph.

The graph is the ultimate solution to represent complex tracks,
manipulate and inspect them for finer analysis. A mathematical graph is a
data structure made of vertices (in our case, spots) connected by edges
(in our case links between spots). Graphs have numerous uses, which
fostered the advent of graph theory and its applications.  With a graph
data structure, you get the tools to iterate, partition, edit and
investigate the data like you could never do with linear data structures.

MATLAB offers two main graph classes, one for undirected graphs (the
direction of edges do not matter) and directed graphs (edges are
directed). We rely of course on the later, which is named \texttt{digraph}. It
was introduced in MATLAB R2015b, so you need at least this version for
what follows.

The function \texttt{trackmateGraph} imports the whole TrackMate data as a
MATLAB \texttt{digraph}. Doing so, spot and edge features are imported as well,
so this function can replace the two preceeding ones. It offers optional
arguments to import a subset of features, as for \texttt{trackmateSpots} and
% \texttt{trackmateEdges}, plus an extra optinal flag for verbosity. They are all
documented in the help section of the function.

Import all features and be verbose during import.
G = trackmateGraph( file_path, [], [], true );

%% 
The graph structure stores teh spots and links features in tables:

Spots.
G.Nodes(1:5, feature_subset)

Edges.
G.Edges(1:6, 1:5)

%%
These tables have the same shape that the tables imported by
% \texttt{trackmateSpots} and \texttt{trackmateEdges}, except for the edge table, whose
first column \texttt{EndNodes} is a N x 2 array that stores the source and
target indices of nodes in the spot table. Careful: these indices are
% \textbf{row numbers} in the spot table.

Access one edge:
i_edge = 28; % 28th edge from AB to AB.p
edge = G.Edges(i_edge, 1:5);
source = G.Nodes( edge.EndNodes(1), feature_subset )
target = G.Nodes( edge.EndNodes(2), feature_subset )

%%
We can now rely on MATLAB facilities to lay out the graph. For instance
you can create a graph display that resembles TrackScheme using the
% \texttt{layered} option of the the plot function, and setting the nodes Y
coordinates to the spot frame:

figure
hp = plot(G, 'layout', 'layered');
set(hp, 'YData', G.Nodes.FRAME);
set(gca, 'YDir', 'reverse', 'XColor', 'none')
ylabel('Time point')
box off

%%
As said above, there is a rich collection of tools offered to manipulate
a graph. Here is a few examples. For instance, suppose we want to color
on this graph all the descendant of the MS cell.

Find the first occurence of MS using spot names.
index_MS = find( strcmp( G.Nodes.name, 'MS'), 1 );

Use depth first iterator to have all its descendant. This will work since
our graph is a directed graph. The following instruction generates a
table with nodes indices (when they are met for the first time) and edge
indices (when they are traversed).
t = dfsearch(G, index_MS, { 'discovernode', 'edgetonew' } );

We have to prune NaNs if we want a separate list of nodes and edges.
v = t.Node;
v = v( ~isnan(v) );
e = t.Edge;
e = e( ~isnan(e(:,1)), : );


Highlight them in the plot:
Nodes
col1 = [ 0.8 0.2 0.1 ];
highlight( hp, v, 'NodeColor', col1)
Edges
highlight( hp, e(:,1), e(:,2), 'EdgeColor', col1)

%%
Now let's find a path in the graph, from AB to AB.araappp

index_AB1 = find( strcmp( G.Nodes.name, 'AB'), 1 );
index_AB2 = find( strcmp( G.Nodes.name, 'AB.araappp'), 1 );

path_AB = shortestpath( G, index_AB1, index_AB2 );
col2 = [ 0.1 0.5 0.2 ];
The highlight function can color edges of a path automatically.
highlight( hp, path_AB,  'NodeColor', col2, 'EdgeColor', col2 )

%%
We can also layout the graph using the spot coordinates for the nodes in
the plot. Unfortunately, the plot function of MATLAB allows for
specifying on the X and Y coordinates. If we want to reproduce the tracks
in 3D with cell fate, we have to generate our own plotting function. Here
is a procedure adapted from the work of John Gilbert:

Get X, Y, Z coordinates.
x = G.Nodes.POSITION_X;
y = G.Nodes.POSITION_Y;
z = G.Nodes.POSITION_Z;

Get links source and target.
s = G.Edges.EndNodes( : , 1 );
t = G.Edges.EndNodes( : , 2 );

We intercalate NaNs between node pairs to have a line for each edge.
n_nodes = numel(s);
X = [ x(s) x(t) NaN( n_nodes, 1) ]';
Y = [ y(s) y(t) NaN( n_nodes, 1) ]';
Z = [ z(s) z(t) NaN( n_nodes, 1) ]';
X = X(:);
Y = Y(:);
Z = Z(:);

figure
plot3( X, Y, Z, '-', 'Color', [ 0.5 0.5 0.5 ] )
xlabel( [ 'X (' char(spot_table.Properties.VariableUnits(22)) ')' ] )
ylabel( [ 'Y (' char(spot_table.Properties.VariableUnits(23)) ')' ] )
zlabel( [ 'Z (' char(spot_table.Properties.VariableUnits(24)) ')' ] )
view(-150, 30)
axis equal

%%
We can also reuse the edges of the MS descendant calculated above to
repaint these descendants in another color on this 3D plot:

The variable e stores MS descendants edges.
s = e(:,1);
t = e(:,2);

Same procedure otherwise:
n_nodes = numel(s);
Xms = [ x(s) x(t) NaN( n_nodes, 1) ]';
Yms = [ y(s) y(t) NaN( n_nodes, 1) ]';
Zms = [ z(s) z(t) NaN( n_nodes, 1) ]';
Xms = Xms(:);
Yms = Yms(:);
Zms = Zms(:);

hold on
plot3( Xms, Yms, Zms, '-', 'Color', col1, 'LineWidth', 2)

%%
Now if we want to color a path, we have to access the edges of this
path, which we cannot do with the simple \texttt{shortestpath} function. We have
to rely on \texttt{shortestpathtree}, which returns a \texttt{digraph} with the
relevant edges only:

path_AB2 = shortestpathtree( G, index_AB1, index_AB2 );

We get edges from the created digraph:
s = path_AB2.Edges.EndNodes(:,1);
t = path_AB2.Edges.EndNodes(:,2);

Same procedure otherwise:
n_nodes = numel(s);
Xab = [ x(s) x(t) NaN( n_nodes, 1) ]';
Yab = [ y(s) y(t) NaN( n_nodes, 1) ]';
Zab = [ z(s) z(t) NaN( n_nodes, 1) ]';
Xab = Xab(:);
Yab = Yab(:);
Zab = Zab(:);

hold on
plot3( Xab, Yab, Zab, 'o-', 'Color', col2, 'LineWidth', 2, ...
    'MarkerFaceColor', 'w')

\subsection{Other MATLAB functions for TrackMate.}
The three sections above presented the core of interoperability between
TrackMate and MATLAB. The main function is \texttt{trackmateGraph} but
% \texttt{trackmateSpots} and \texttt{trackmateEdges} can be used advantageously when the
whole graph is not required for analysis. The logic used in these
three functions can be reproduced and translated to languages other than
MATLAB.

There are two supplemental functions that do not import the track data
but are useful to probe the metadata stored in a TrackMate file.
% \texttt{trackmateImageCalibration} is able to read the physical calibration of
the image on which TrackMate operated:

cal = trackmateImageCalibration( file_path );
cal.x

%%
The function \texttt{trackmateFeatureDeclarations} is used to probe what
features are declared in the TrackMate file:

[ spot_fd, edge_fd, track_df ] = trackmateFeatureDeclarations( file_path );

%% 
They are returned as 3 maps, one for spot, edge and track feature
declarations. These maps use the feature names as keys:

edge_fd('VELOCITY')
